import { TextMessageStartEvent, TextMessageContentEvent, TextMessageEndEvent, ThinkingTextMessageStartEvent, ThinkingTextMessageContentEvent, ThinkingTextMessageEndEvent, ToolCallStartEvent, ToolCallArgsEvent, ToolCallEndEvent, ThinkingStartEvent, ThinkingEndEvent, StateSnapshotEvent, StateDeltaEvent, MessagesSnapshotEvent, RawEvent, CustomEvent, RunStartedEvent, RunFinishedEvent, RunErrorEvent, StepStartedEvent, StepFinishedEvent, AgentConfig, AbstractAgent, RunAgentInput, HttpAgent } from '@ag-ui/client';
import * as _langchain_langgraph_sdk from '@langchain/langgraph-sdk';
import { Message, Client, Config, Assistant, StreamMode, Thread } from '@langchain/langgraph-sdk';
import { Subscriber, Observable } from 'rxjs';
import { MessageType } from '@langchain/core/messages';
import { RunsStreamPayload } from '@langchain/langgraph-sdk/dist/types';

declare enum LangGraphEventTypes {
    OnChainStart = "on_chain_start",
    OnChainStream = "on_chain_stream",
    OnChainEnd = "on_chain_end",
    OnChatModelStart = "on_chat_model_start",
    OnChatModelStream = "on_chat_model_stream",
    OnChatModelEnd = "on_chat_model_end",
    OnToolStart = "on_tool_start",
    OnToolEnd = "on_tool_end",
    OnCustomEvent = "on_custom_event",
    OnInterrupt = "on_interrupt"
}
type State = Record<string, any>;
type SchemaKeys = {
    input: string[] | null;
    output: string[] | null;
    config: string[] | null;
} | null;
type MessageInProgress = {
    id: string;
    toolCallId?: string | null;
    toolCallName?: string | null;
};
type ThinkingInProgress = {
    index: number;
    type?: LangGraphReasoning['type'];
};
interface RunMetadata {
    id: string;
    schemaKeys?: SchemaKeys;
    nodeName?: string;
    prevNodeName?: string | null;
    exitingNode?: boolean;
    manuallyEmittedState?: State | null;
    threadId?: string;
}
type MessagesInProgressRecord = Record<string, MessageInProgress | null>;
interface ToolCall {
    id: string;
    name: string;
    args: Record<string, unknown>;
}
type BaseLangGraphPlatformMessage = Omit<Message, "isResultMessage" | "isTextMessage" | "isImageMessage" | "isActionExecutionMessage" | "isAgentStateMessage" | "type" | "createdAt"> & {
    content: string;
    role: string;
    additional_kwargs?: Record<string, unknown>;
    type: MessageType;
};
interface LangGraphPlatformResultMessage extends BaseLangGraphPlatformMessage {
    tool_call_id: string;
    name: string;
}
interface LangGraphPlatformActionExecutionMessage extends BaseLangGraphPlatformMessage {
    tool_calls: ToolCall[];
}
type LangGraphPlatformMessage = LangGraphPlatformActionExecutionMessage | LangGraphPlatformResultMessage | BaseLangGraphPlatformMessage;
declare enum CustomEventNames {
    ManuallyEmitMessage = "manually_emit_message",
    ManuallyEmitToolCall = "manually_emit_tool_call",
    ManuallyEmitState = "manually_emit_state",
    Exit = "exit"
}
interface PredictStateTool {
    tool: string;
    state_key: string;
    tool_argument: string;
}
interface LangGraphReasoning {
    type: 'text';
    text: string;
    index: number;
}

type ProcessedEvents = TextMessageStartEvent | TextMessageContentEvent | TextMessageEndEvent | ThinkingTextMessageStartEvent | ThinkingTextMessageContentEvent | ThinkingTextMessageEndEvent | ToolCallStartEvent | ToolCallArgsEvent | ToolCallEndEvent | ThinkingStartEvent | ThinkingEndEvent | StateSnapshotEvent | StateDeltaEvent | MessagesSnapshotEvent | RawEvent | CustomEvent | RunStartedEvent | RunFinishedEvent | RunErrorEvent | StepStartedEvent | StepFinishedEvent;
type RunAgentExtendedInput<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false> = Omit<RunAgentInput, "forwardedProps"> & {
    forwardedProps?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, "input"> & {
        nodeName?: string;
        threadMetadata?: Record<string, any>;
    };
};
interface LangGraphAgentConfig extends AgentConfig {
    client?: Client;
    deploymentUrl: string;
    langsmithApiKey?: string;
    propertyHeaders?: Record<string, string>;
    assistantConfig?: Config;
    agentName?: string;
    graphId: string;
}
declare class LangGraphAgent extends AbstractAgent {
    client: Client;
    assistantConfig?: Config;
    agentName?: string;
    graphId: string;
    assistant?: Assistant;
    messagesInProcess: MessagesInProgressRecord;
    thinkingProcess: null | ThinkingInProgress;
    activeRun?: RunMetadata;
    subscriber: Subscriber<ProcessedEvents>;
    constructor(config: LangGraphAgentConfig);
    dispatchEvent(event: ProcessedEvents): boolean;
    run(input: RunAgentInput): Observable<ProcessedEvents>;
    handleStreamEvents(input: RunAgentExtendedInput, subscriber: Subscriber<ProcessedEvents>): Promise<void>;
    handleSingleEvent(event: any, state: State): void;
    handleThinkingEvent(reasoningData: LangGraphReasoning): void;
    getStateSnapshot(state: State): State;
    getOrCreateThread(threadId: string, threadMetadata?: Record<string, any>): Promise<Thread>;
    getThread(threadId: string): Promise<Thread<_langchain_langgraph_sdk.DefaultValues>>;
    createThread(payload?: Parameters<typeof this$1.client.threads.create>[0]): Promise<Thread<_langchain_langgraph_sdk.DefaultValues>>;
    mergeConfigs({ configs, assistant, schemaKeys, }: {
        configs: Config[];
        assistant: Assistant;
        schemaKeys: SchemaKeys;
    }): Promise<Config>;
    getMessageInProgress(runId: string): MessageInProgress | null;
    setMessageInProgress(runId: string, data: MessageInProgress): void;
    getAssistant(): Promise<Assistant>;
    getSchemaKeys(): Promise<SchemaKeys>;
    langGraphDefaultMergeState(state: State, messages: Message[], tools: any): State;
    startStep(nodeName: string): void;
    endStep(): void;
}

declare class LangGraphHttpAgent extends HttpAgent {
}

export { CustomEventNames, LangGraphAgent, type LangGraphAgentConfig, LangGraphEventTypes, LangGraphHttpAgent, type LangGraphPlatformMessage, type LangGraphReasoning, type MessageInProgress, type MessagesInProgressRecord, type PredictStateTool, type ProcessedEvents, type RunMetadata, type SchemaKeys, type State, type ThinkingInProgress, type ToolCall };
