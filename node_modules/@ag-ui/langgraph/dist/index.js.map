{"version":3,"sources":["../src/index.ts","../src/agent.ts","../src/types.ts","../src/utils.ts"],"sourcesContent":["import { HttpAgent } from \"@ag-ui/client\";\n\nexport * from './agent'\nexport class LangGraphHttpAgent extends HttpAgent {}","import { Observable, Subscriber } from \"rxjs\";\nimport {\n  Client as LangGraphClient,\n  EventsStreamEvent,\n  StreamMode,\n  Config as LangGraphConfig,\n  ThreadState,\n  Assistant,\n  Message as LangGraphMessage,\n  Config,\n  Interrupt,\n  Thread\n} from \"@langchain/langgraph-sdk\";\nimport { randomUUID } from \"node:crypto\";\nimport { RemoveMessage } from \"@langchain/core/messages\";\nimport {\n  LangGraphPlatformMessage,\n  CustomEventNames,\n  LangGraphEventTypes,\n  State,\n  MessagesInProgressRecord,\n  ThinkingInProgress,\n  SchemaKeys,\n  MessageInProgress,\n  RunMetadata,\n  PredictStateTool,\n  LangGraphReasoning\n} from \"./types\";\nimport {\n  AbstractAgent,\n  AgentConfig,\n  CustomEvent,\n  EventType,\n  MessagesSnapshotEvent,\n  RawEvent,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n  ThinkingTextMessageStartEvent,\n  ThinkingTextMessageContentEvent,\n  ThinkingTextMessageEndEvent,\n  ThinkingStartEvent,\n  ThinkingEndEvent,\n} from \"@ag-ui/client\";\nimport { RunsStreamPayload } from \"@langchain/langgraph-sdk/dist/types\";\nimport {\n  aguiMessagesToLangChain,\n  DEFAULT_SCHEMA_KEYS,\n  filterObjectBySchemaKeys,\n  getStreamPayloadInput,\n  langchainMessagesToAgui,\n  resolveMessageContent,\n  resolveReasoningContent\n} from \"@/utils\";\n\nexport type ProcessedEvents =\n  | TextMessageStartEvent\n  | TextMessageContentEvent\n  | TextMessageEndEvent\n  | ThinkingTextMessageStartEvent\n  | ThinkingTextMessageContentEvent\n  | ThinkingTextMessageEndEvent\n  | ToolCallStartEvent\n  | ToolCallArgsEvent\n  | ToolCallEndEvent\n  | ThinkingStartEvent\n  | ThinkingEndEvent\n  | StateSnapshotEvent\n  | StateDeltaEvent\n  | MessagesSnapshotEvent\n  | RawEvent\n  | CustomEvent\n  | RunStartedEvent\n  | RunFinishedEvent\n  | RunErrorEvent\n  | StepStartedEvent\n  | StepFinishedEvent;\n\ntype RunAgentExtendedInput<\n  TStreamMode extends StreamMode | StreamMode[] = StreamMode,\n  TSubgraphs extends boolean = false,\n> = Omit<RunAgentInput, \"forwardedProps\"> & {\n  forwardedProps?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, \"input\"> & {\n    nodeName?: string;\n    threadMetadata?: Record<string, any>;\n  };\n};\n\nexport interface LangGraphAgentConfig extends AgentConfig {\n  client?: LangGraphClient;\n  deploymentUrl: string;\n  langsmithApiKey?: string;\n  propertyHeaders?: Record<string, string>;\n  assistantConfig?: LangGraphConfig;\n  agentName?: string;\n  graphId: string;\n}\n\nexport class LangGraphAgent extends AbstractAgent {\n  client: LangGraphClient;\n  assistantConfig?: LangGraphConfig;\n  agentName?: string;\n  graphId: string;\n  assistant?: Assistant;\n  messagesInProcess: MessagesInProgressRecord;\n  thinkingProcess: null | ThinkingInProgress;\n  activeRun?: RunMetadata;\n  // @ts-expect-error no need to initialize subscriber right now\n  subscriber: Subscriber<ProcessedEvents>;\n\n  constructor(config: LangGraphAgentConfig) {\n    super(config);\n    this.messagesInProcess = {};\n    this.agentName = config.agentName;\n    this.graphId = config.graphId;\n    this.assistantConfig = config.assistantConfig;\n    this.thinkingProcess = null\n    this.client =\n      config?.client ??\n      new LangGraphClient({\n        apiUrl: config.deploymentUrl,\n        apiKey: config.langsmithApiKey,\n        defaultHeaders: { ...(config.propertyHeaders ?? {}) },\n      });\n  }\n\n  dispatchEvent(event: ProcessedEvents) {\n    this.subscriber.next(event);\n    return true;\n  }\n\n  run(input: RunAgentInput) {\n    this.activeRun = {\n      id: input.runId,\n      threadId: input.threadId,\n    };\n    return new Observable<ProcessedEvents>((subscriber) => {\n      this.handleStreamEvents(input, subscriber);\n      return () => {};\n    });\n  }\n\n  async handleStreamEvents(input: RunAgentExtendedInput, subscriber: Subscriber<ProcessedEvents>) {\n    let { threadId: inputThreadId, state, messages, tools, context, forwardedProps } = input;\n    this.subscriber = subscriber;\n    let shouldExit = false;\n    // If a manual emittance happens, it is the ultimate source of truth of state, unless a node has exited.\n    // Therefore, this value should either hold null, or the only edition of state that should be used.\n    this.activeRun!.manuallyEmittedState = null;\n\n    const nodeNameInput = forwardedProps?.nodeName;\n    this.activeRun!.nodeName = nodeNameInput;\n    if (this.activeRun!.nodeName === '__end__') {\n      this.activeRun!.nodeName = undefined;\n    }\n\n    const threadId = inputThreadId ?? randomUUID();\n\n    if (!this.assistant) {\n      this.assistant = await this.getAssistant();\n    }\n\n    const thread = await this.getOrCreateThread(threadId, forwardedProps?.threadMetadata);\n    this.activeRun!.threadId = thread.thread_id;\n    const agentState = await this.client.threads.getState(thread.thread_id) ?? { values: {} } as ThreadState\n\n    const agentStateValues = agentState.values as State;\n    const aguiToLangChainMessage = aguiMessagesToLangChain(messages);\n\n    state.messages = agentStateValues.messages;\n    state = this.langGraphDefaultMergeState(state, aguiToLangChainMessage, tools);\n    const graphInfo = await this.client.assistants.getGraph(this.assistant.assistant_id);\n\n    const mode =\n      threadId && this.activeRun!.nodeName != \"__end__\" && this.activeRun!.nodeName\n        ? \"continue\"\n        : \"start\";\n\n    if (mode === \"continue\" && !forwardedProps?.command?.resume) {\n      const nodeBefore = graphInfo.edges.find(e => e.target === this.activeRun!.nodeName);\n      await this.client.threads.updateState(threadId, {\n        values: state,\n        asNode: nodeBefore?.source,\n      });\n    }\n    this.activeRun!.schemaKeys = await this.getSchemaKeys();\n\n    const payloadInput = getStreamPayloadInput({\n      mode,\n      state,\n      schemaKeys: this.activeRun!.schemaKeys,\n    });\n\n    let payloadConfig: LangGraphConfig | undefined;\n    const configsToMerge = [this.assistantConfig, forwardedProps?.config].filter(\n      Boolean,\n    ) as LangGraphConfig[];\n    if (configsToMerge.length) {\n      payloadConfig = await this.mergeConfigs({\n        configs: configsToMerge,\n        assistant: this.assistant,\n        schemaKeys: this.activeRun!.schemaKeys,\n      });\n    }\n    const payload = {\n      ...forwardedProps,\n      streamMode:\n        forwardedProps?.streamMode ?? ([\"events\", \"values\", \"updates\"] satisfies StreamMode[]),\n      input: payloadInput,\n      config: payloadConfig,\n    };\n\n    // If there are still outstanding unresolved interrupts, we must force resolution of them before moving forward\n    const interrupts = (agentState.tasks?.[0]?.interrupts ?? []) as Interrupt[];\n    if (interrupts?.length && !forwardedProps?.command?.resume) {\n      this.dispatchEvent({\n        type: EventType.RUN_STARTED,\n        threadId,\n        runId: input.runId,\n      });\n\n      interrupts.forEach((interrupt) => {\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: LangGraphEventTypes.OnInterrupt,\n          value:\n            typeof interrupt.value === \"string\" ? interrupt.value : JSON.stringify(interrupt.value),\n          rawEvent: interrupt,\n        });\n      });\n\n      this.dispatchEvent({\n        type: EventType.RUN_FINISHED,\n        threadId,\n        runId: input.runId,\n      });\n      return subscriber.complete();\n    }\n\n    const streamResponse = this.client.runs.stream(threadId, this.assistant.assistant_id, payload);\n\n    this.activeRun!.prevNodeName = null;\n    let latestStateValues = {};\n    let updatedState = state;\n\n    try {\n      this.dispatchEvent({\n        type: EventType.RUN_STARTED,\n        threadId,\n        runId: this.activeRun!.id,\n      });\n\n      for await (let streamResponseChunk of streamResponse) {\n        // @ts-ignore\n        if (!payload.streamMode.includes(streamResponseChunk.event as StreamMode)) {\n          continue;\n        }\n\n        // Force event type, as data is not properly defined on the LG side.\n        type EventsChunkData = {\n          __interrupt__?: any;\n          metadata: Record<string, any>;\n          event: string;\n          data: any;\n          [key: string]: unknown;\n        };\n        const chunk = streamResponseChunk as EventsStreamEvent & { data: EventsChunkData };\n\n        if (streamResponseChunk.event === \"error\") {\n          this.dispatchEvent({\n            type: EventType.RUN_ERROR,\n            message: streamResponseChunk.data.message,\n            rawEvent: streamResponseChunk,\n          });\n          break;\n        }\n\n        if (streamResponseChunk.event === \"updates\") continue;\n\n        if (streamResponseChunk.event === \"values\") {\n          latestStateValues = chunk.data;\n          continue;\n        }\n\n        const chunkData = chunk.data;\n        const currentNodeName = chunkData.metadata.langgraph_node;\n        const eventType = chunkData.event;\n        const metadata = chunkData.metadata;\n        this.activeRun!.id = metadata.run_id;\n\n        if (currentNodeName && currentNodeName !== this.activeRun!.nodeName) {\n          if (this.activeRun!.nodeName && this.activeRun!.nodeName !== nodeNameInput) {\n            this.endStep()\n          }\n\n          this.startStep(currentNodeName)\n        }\n\n        shouldExit =\n          shouldExit ||\n          (eventType === LangGraphEventTypes.OnCustomEvent &&\n            chunkData.name === CustomEventNames.Exit);\n\n        this.activeRun!.exitingNode =\n          this.activeRun!.nodeName === currentNodeName &&\n          eventType === LangGraphEventTypes.OnChainEnd;\n        if (this.activeRun!.exitingNode) {\n          this.activeRun!.manuallyEmittedState = null;\n        }\n\n        // we only want to update the node name under certain conditions\n        // since we don't need any internal node names to be sent to the frontend\n        if (graphInfo[\"nodes\"].some((node) => node.id === currentNodeName)) {\n          this.activeRun!.nodeName = currentNodeName\n        }\n\n        updatedState = this.activeRun!.manuallyEmittedState ?? latestStateValues;\n\n        if (!this.activeRun!.nodeName) {\n          continue;\n        }\n\n        const hasStateDiff = JSON.stringify(updatedState) !== JSON.stringify(state);\n        // We should not update snapshot while a message is in progress.\n        if (\n          (hasStateDiff ||\n            this.activeRun!.prevNodeName != this.activeRun!.nodeName ||\n            this.activeRun!.exitingNode) &&\n          !Boolean(this.getMessageInProgress(this.activeRun!.id))\n        ) {\n          state = updatedState;\n          this.activeRun!.prevNodeName = this.activeRun!.nodeName;\n\n          this.dispatchEvent({\n            type: EventType.STATE_SNAPSHOT,\n            snapshot: this.getStateSnapshot(state),\n            rawEvent: chunk,\n          });\n        }\n\n        this.dispatchEvent({\n          type: EventType.RAW,\n          event: chunkData,\n        });\n\n        this.handleSingleEvent(chunkData, state);\n      }\n\n      state = await this.client.threads.getState(threadId);\n      const tasks = state.tasks\n      const interrupts = (tasks?.[0]?.interrupts ?? []) as Interrupt[];\n      const isEndNode = state.next.length === 0\n      const writes = state.metadata.writes ?? {}\n\n      let newNodeName = this.activeRun!.nodeName!\n\n      if (!interrupts?.length) {\n        newNodeName = isEndNode ? '__end__' : (state.next[0] ?? Object.keys(writes)[0]);\n      }\n\n\n      interrupts.forEach((interrupt) => {\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: LangGraphEventTypes.OnInterrupt,\n          value:\n            typeof interrupt.value === \"string\" ? interrupt.value : JSON.stringify(interrupt.value),\n          rawEvent: interrupt,\n        });\n      });\n\n      if (this.activeRun!.nodeName != newNodeName) {\n        this.endStep()\n        this.startStep(newNodeName)\n      }\n\n      this.endStep()\n      this.dispatchEvent({\n        type: EventType.STATE_SNAPSHOT,\n        snapshot: this.getStateSnapshot(state.values),\n      });\n      this.dispatchEvent({\n        type: EventType.MESSAGES_SNAPSHOT,\n        messages: langchainMessagesToAgui(state.values.messages ?? []),\n      });\n\n      this.dispatchEvent({\n        type: EventType.RUN_FINISHED,\n        threadId,\n        runId: this.activeRun!.id,\n      });\n      this.activeRun = undefined;\n      return subscriber.complete();\n    } catch (e) {\n      return subscriber.error(e);\n    }\n  }\n\n  handleSingleEvent(event: any, state: State): void {\n    switch (event.event) {\n      case LangGraphEventTypes.OnChatModelStream:\n        let shouldEmitMessages = event.metadata[\"emit-messages\"] ?? true;\n        let shouldEmitToolCalls = event.metadata[\"emit-tool-calls\"] ?? true;\n\n        if (event.data.chunk.response_metadata.finish_reason) return;\n        let currentStream = this.getMessageInProgress(this.activeRun!.id);\n        const hasCurrentStream = Boolean(currentStream?.id);\n        const toolCallData = event.data.chunk.tool_call_chunks?.[0];\n        const toolCallUsedToPredictState = event.metadata[\"predict_state\"]?.some(\n          (predictStateTool: PredictStateTool) => predictStateTool.tool === toolCallData?.name,\n        );\n\n        const isToolCallStartEvent = !hasCurrentStream && toolCallData?.name;\n        const isToolCallArgsEvent =\n          hasCurrentStream && currentStream?.toolCallId && toolCallData?.args;\n        const isToolCallEndEvent = hasCurrentStream && currentStream?.toolCallId && !toolCallData;\n\n        const reasoningData = resolveReasoningContent(event.data);\n        const messageContent = resolveMessageContent(event.data.chunk.content);\n        const isMessageContentEvent = Boolean(!toolCallData && messageContent);\n\n        const isMessageEndEvent =\n          hasCurrentStream && !currentStream?.toolCallId && !isMessageContentEvent;\n\n        if (reasoningData) {\n          this.handleThinkingEvent(reasoningData)\n          break;\n        }\n\n        if (!reasoningData && this.thinkingProcess) {\n          this.dispatchEvent({\n            type: EventType.THINKING_TEXT_MESSAGE_END,\n          })\n          this.dispatchEvent({\n            type: EventType.THINKING_END,\n          })\n          this.thinkingProcess = null;\n        }\n\n        if (toolCallUsedToPredictState) {\n          this.dispatchEvent({\n            type: EventType.CUSTOM,\n            name: \"PredictState\",\n            value: event.metadata[\"predict_state\"],\n          });\n        }\n\n        if (isToolCallEndEvent) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: currentStream?.toolCallId!,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n\n        if (isMessageEndEvent) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: currentStream!.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n\n        if (isToolCallStartEvent && shouldEmitToolCalls) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_START,\n            toolCallId: toolCallData.id,\n            toolCallName: toolCallData.name,\n            parentMessageId: event.data.chunk.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.setMessageInProgress(this.activeRun!.id, {\n              id: event.data.chunk.id,\n              toolCallId: toolCallData.id,\n              toolCallName: toolCallData.name,\n            });\n          }\n          break;\n        }\n\n        // Tool call args: emit ActionExecutionArgs\n        if (isToolCallArgsEvent && shouldEmitToolCalls) {\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_ARGS,\n            toolCallId: currentStream?.toolCallId!,\n            delta: toolCallData.args,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        // Message content: emit TextMessageContent\n        if (isMessageContentEvent && shouldEmitMessages) {\n          // No existing message yet, also init the message\n          if (!currentStream) {\n            this.dispatchEvent({\n              type: EventType.TEXT_MESSAGE_START,\n              role: \"assistant\",\n              messageId: event.data.chunk.id,\n              rawEvent: event,\n            });\n            this.setMessageInProgress(this.activeRun!.id, {\n              id: event.data.chunk.id,\n              toolCallId: null,\n              toolCallName: null,\n            });\n            currentStream = this.getMessageInProgress(this.activeRun!.id);\n          }\n\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_CONTENT,\n            messageId: currentStream!.id,\n            delta: messageContent!,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        break;\n      case LangGraphEventTypes.OnChatModelEnd:\n        if (this.getMessageInProgress(this.activeRun!.id)?.toolCallId) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: this.getMessageInProgress(this.activeRun!.id)!.toolCallId!,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n        if (this.getMessageInProgress(this.activeRun!.id)?.id) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: this.getMessageInProgress(this.activeRun!.id)!.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n        break;\n      case LangGraphEventTypes.OnCustomEvent:\n        if (event.name === CustomEventNames.ManuallyEmitMessage) {\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_START,\n            role: \"assistant\",\n            messageId: event.data.message_id,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_CONTENT,\n            messageId: event.data.message_id,\n            delta: event.data.message,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: event.data.message_id,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        if (event.name === CustomEventNames.ManuallyEmitToolCall) {\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_START,\n            toolCallId: event.data.id,\n            toolCallName: event.data.name,\n            parentMessageId: event.data.id,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_ARGS,\n            toolCallId: event.data.id,\n            delta: event.data.args,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: event.data.id,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        if (event.name === CustomEventNames.ManuallyEmitState) {\n          this.activeRun!.manuallyEmittedState = event.data;\n          this.dispatchEvent({\n            type: EventType.STATE_SNAPSHOT,\n            snapshot: this.getStateSnapshot(state),\n            rawEvent: event,\n          });\n        }\n\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: event.name,\n          value: event.data,\n          rawEvent: event,\n        });\n        break;\n    }\n  }\n\n  handleThinkingEvent(reasoningData: LangGraphReasoning) {\n    if (!reasoningData || !reasoningData.type || !reasoningData.text) {\n      return;\n    }\n\n    const thinkingStepIndex = reasoningData.index;\n\n    if (this.thinkingProcess?.index && this.thinkingProcess.index !== thinkingStepIndex) {\n      if (this.thinkingProcess.type) {\n        this.dispatchEvent({\n          type: EventType.THINKING_TEXT_MESSAGE_END,\n        })\n      }\n      this.dispatchEvent({\n        type: EventType.THINKING_END,\n      })\n      this.thinkingProcess = null;\n    }\n\n    if (!this.thinkingProcess) {\n      // No thinking step yet. Start a new one\n      this.dispatchEvent({\n        type: EventType.THINKING_START,\n      })\n      this.thinkingProcess = {\n        index: thinkingStepIndex,\n      };\n    }\n\n\n    if (this.thinkingProcess.type !== reasoningData.type) {\n      this.dispatchEvent({\n        type: EventType.THINKING_TEXT_MESSAGE_START,\n      })\n      this.thinkingProcess.type = reasoningData.type\n    }\n\n    if (this.thinkingProcess.type) {\n      this.dispatchEvent({\n        type: EventType.THINKING_TEXT_MESSAGE_CONTENT,\n        delta: reasoningData.text\n      })\n    }\n  }\n\n  getStateSnapshot(state: State) {\n    const schemaKeys = this.activeRun!.schemaKeys!;\n    // Do not emit state keys that are not part of the output schema\n    if (schemaKeys?.output) {\n      state = filterObjectBySchemaKeys(state, [...DEFAULT_SCHEMA_KEYS, ...schemaKeys.output]);\n    }\n    // return state\n    return state;\n  }\n\n  async getOrCreateThread(threadId: string, threadMetadata?: Record<string, any>): Promise<Thread> {\n    let thread: Thread;\n    try {\n      try {\n        thread = await this.getThread(threadId);\n      } catch (error) {\n        thread = await this.createThread({\n          threadId,\n          metadata: threadMetadata\n        });\n      }\n    } catch (error: unknown) {\n      throw new Error(`Failed to create thread: ${(error as Error).message}`);\n    }\n\n    return thread;\n  }\n\n  async getThread(threadId: string) {\n    return this.client.threads.get(threadId);\n  }\n\n  async createThread(payload?: Parameters<typeof this.client.threads.create>[0]) {\n    return this.client.threads.create(payload);\n  }\n\n  async mergeConfigs({\n                       configs,\n                       assistant,\n                       schemaKeys,\n                     }: {\n    configs: Config[];\n    assistant: Assistant;\n    schemaKeys: SchemaKeys;\n  }) {\n    return configs.reduce((acc, cfg) => {\n      let filteredConfigurable = acc.configurable;\n\n      if (cfg.configurable) {\n        filteredConfigurable = schemaKeys?.config\n          ? filterObjectBySchemaKeys(cfg?.configurable, [\n            ...DEFAULT_SCHEMA_KEYS,\n            ...(schemaKeys?.config ?? []),\n          ])\n          : cfg?.configurable;\n      }\n\n      const newConfig = {\n        ...acc,\n        ...cfg,\n        configurable: filteredConfigurable,\n      };\n\n      // LG does not return recursion limit if it's the default, therefore we check: if no recursion limit is currently set, and the user asked for 25, there is no change.\n      const isRecursionLimitSetToDefault =\n        acc.recursion_limit == null && cfg.recursion_limit === 25;\n      // Deep compare configs to avoid unnecessary update calls\n      const configsAreDifferent = JSON.stringify(newConfig) !== JSON.stringify(acc);\n\n      // Check if the only difference is the recursion_limit being set to default\n      const isOnlyRecursionLimitDifferent =\n        isRecursionLimitSetToDefault &&\n        JSON.stringify({ ...newConfig, recursion_limit: null }) ===\n        JSON.stringify({ ...acc, recursion_limit: null });\n\n      if (configsAreDifferent && !isOnlyRecursionLimitDifferent) {\n        return {\n          ...acc,\n          ...newConfig,\n        };\n      }\n\n      return acc;\n    }, assistant.config);\n  }\n\n  getMessageInProgress(runId: string) {\n    return this.messagesInProcess[runId];\n  }\n\n  setMessageInProgress(runId: string, data: MessageInProgress) {\n    this.messagesInProcess = {\n      ...this.messagesInProcess,\n      [runId]: {\n        ...(this.messagesInProcess[runId] as MessageInProgress),\n        ...data,\n      },\n    };\n  }\n\n  async getAssistant(): Promise<Assistant> {\n    const assistants = await this.client.assistants.search();\n    const retrievedAssistant = assistants.find(\n      (searchResult) =>\n        searchResult.graph_id === this.graphId,\n    );\n    if (!retrievedAssistant) {\n      console.error(`\n      No agent found with graph ID ${this.graphId} found..\\n\n      \n      These are the available agents: [${assistants.map((a) => `${a.graph_id} (ID: ${a.assistant_id})`).join(\", \")}]\n      `);\n      throw new Error(\"No agent id found\");\n    }\n\n    return retrievedAssistant;\n  }\n\n  async getSchemaKeys(): Promise<SchemaKeys> {\n    const CONSTANT_KEYS = [\"messages\"];\n\n    try {\n      const graphSchema = await this.client.assistants.getSchemas(this.assistant!.assistant_id);\n      let configSchema = null;\n      if (graphSchema.config_schema?.properties) {\n        configSchema = Object.keys(graphSchema.config_schema.properties);\n      }\n      if (!graphSchema.input_schema?.properties || !graphSchema.output_schema?.properties) {\n        return { config: [], input: CONSTANT_KEYS, output: CONSTANT_KEYS };\n      }\n      const inputSchema = Object.keys(graphSchema.input_schema.properties);\n      const outputSchema = Object.keys(graphSchema.output_schema.properties);\n\n      return {\n        input: inputSchema && inputSchema.length ? [...inputSchema, ...CONSTANT_KEYS] : null,\n        output: outputSchema && outputSchema.length ? [...outputSchema, ...CONSTANT_KEYS] : null,\n        config: configSchema,\n      };\n    } catch (e) {\n      return { config: [], input: CONSTANT_KEYS, output: CONSTANT_KEYS };\n    }\n  }\n\n  langGraphDefaultMergeState(state: State, messages: LangGraphMessage[], tools: any): State {\n    if (messages.length > 0 && \"role\" in messages[0] && messages[0].role === \"system\") {\n      // remove system message\n      messages = messages.slice(1);\n    }\n\n    // merge with existing messages\n    const existingMessages: LangGraphPlatformMessage[] = state.messages || [];\n    const existingMessageIds = new Set(existingMessages.map((message) => message.id));\n    const messageIds = new Set(messages.map((message) => message.id));\n\n    let removedMessages: RemoveMessage[] = [];\n    if (messages.length < existingMessages.length) {\n      // Messages were removed\n      removedMessages = existingMessages\n        .filter((m) => !messageIds.has(m.id))\n        .map((m) => new RemoveMessage({ id: m.id! }));\n    }\n\n    const newMessages = messages.filter((message) => !existingMessageIds.has(message.id));\n\n    return {\n      ...state,\n      messages: [...removedMessages, ...newMessages],\n      tools: [...(state.tools ?? []), ...tools],\n    };\n  }\n\n  startStep(nodeName: string) {\n    this.dispatchEvent({\n      type: EventType.STEP_STARTED,\n      stepName: nodeName,\n    });\n    this.activeRun!.nodeName = nodeName;\n  }\n\n  endStep() {\n    if (!this.activeRun!.nodeName) {\n      throw new Error(\"No active step to end\");\n    }\n    this.dispatchEvent({\n      type: EventType.STEP_FINISHED,\n      stepName: this.activeRun!.nodeName!,\n    });\n    this.activeRun!.nodeName = undefined;\n  }\n}\n\nexport * from \"./types\";\n","import { Message } from \"@langchain/langgraph-sdk\";\nimport { MessageType } from \"@langchain/core/messages\";\n\nexport enum LangGraphEventTypes {\n  OnChainStart = \"on_chain_start\",\n  OnChainStream = \"on_chain_stream\",\n  OnChainEnd = \"on_chain_end\",\n  OnChatModelStart = \"on_chat_model_start\",\n  OnChatModelStream = \"on_chat_model_stream\",\n  OnChatModelEnd = \"on_chat_model_end\",\n  OnToolStart = \"on_tool_start\",\n  OnToolEnd = \"on_tool_end\",\n  OnCustomEvent = \"on_custom_event\",\n  OnInterrupt = \"on_interrupt\",\n}\n\nexport type State = Record<string, any>;\n\nexport type SchemaKeys = {\n  input: string[] | null;\n  output: string[] | null;\n  config: string[] | null;\n} | null;\n\nexport type MessageInProgress = {\n  id: string;\n  toolCallId?: string | null;\n  toolCallName?: string | null;\n};\n\nexport type ThinkingInProgress = {\n  index: number;\n  type?: LangGraphReasoning['type'];\n}\n\nexport interface RunMetadata {\n  id: string;\n  schemaKeys?: SchemaKeys;\n  nodeName?: string;\n  prevNodeName?: string | null;\n  exitingNode?: boolean;\n  manuallyEmittedState?: State | null;\n  threadId?: string;\n}\n\nexport type MessagesInProgressRecord = Record<string, MessageInProgress | null>;\n\n// The following types are our own definition to the messages accepted by LangGraph Platform, enhanced with some of our extra data.\nexport interface ToolCall {\n  id: string;\n  name: string;\n  args: Record<string, unknown>;\n}\n\ntype BaseLangGraphPlatformMessage = Omit<\n  Message,\n  | \"isResultMessage\"\n  | \"isTextMessage\"\n  | \"isImageMessage\"\n  | \"isActionExecutionMessage\"\n  | \"isAgentStateMessage\"\n  | \"type\"\n  | \"createdAt\"\n> & {\n  content: string;\n  role: string;\n  additional_kwargs?: Record<string, unknown>;\n  type: MessageType;\n};\n\ninterface LangGraphPlatformResultMessage extends BaseLangGraphPlatformMessage {\n  tool_call_id: string;\n  name: string;\n}\n\ninterface LangGraphPlatformActionExecutionMessage extends BaseLangGraphPlatformMessage {\n  tool_calls: ToolCall[];\n}\n\nexport type LangGraphPlatformMessage =\n  | LangGraphPlatformActionExecutionMessage\n  | LangGraphPlatformResultMessage\n  | BaseLangGraphPlatformMessage;\n\nexport enum CustomEventNames {\n  ManuallyEmitMessage = \"manually_emit_message\",\n  ManuallyEmitToolCall = \"manually_emit_tool_call\",\n  ManuallyEmitState = \"manually_emit_state\",\n  Exit = \"exit\",\n}\n\nexport interface PredictStateTool {\n  tool: string;\n  state_key: string;\n  tool_argument: string;\n}\n\nexport interface LangGraphReasoning {\n  type: 'text';\n  text: string;\n  index: number\n}\n","import { Message as LangGraphMessage } from \"@langchain/langgraph-sdk\";\nimport { State, SchemaKeys, LangGraphReasoning } from \"./types\";\nimport { Message, ToolCall } from \"@ag-ui/client\";\n\nexport const DEFAULT_SCHEMA_KEYS = [\"tools\"];\n\nexport function filterObjectBySchemaKeys(obj: Record<string, any>, schemaKeys: string[]) {\n  return Object.fromEntries(Object.entries(obj).filter(([key]) => schemaKeys.includes(key)));\n}\n\nexport function getStreamPayloadInput({\n  mode,\n  state,\n  schemaKeys,\n}: {\n  mode: \"start\" | \"continue\";\n  state: State;\n  schemaKeys: SchemaKeys;\n}) {\n  let input = mode === \"start\" ? state : null;\n  // Do not input keys that are not part of the input schema\n  if (input && schemaKeys?.input) {\n    input = filterObjectBySchemaKeys(input, [...DEFAULT_SCHEMA_KEYS, ...schemaKeys.input]);\n  }\n\n  return input;\n}\n\nexport function langchainMessagesToAgui(messages: LangGraphMessage[]): Message[] {\n  return messages.map((message) => {\n    switch (message.type) {\n      case \"human\":\n        return {\n          id: message.id!,\n          role: \"user\",\n          content: stringifyIfNeeded(resolveMessageContent(message.content)),\n        };\n      case \"ai\":\n        const content = resolveMessageContent(message.content)\n        return {\n          id: message.id!,\n          role: \"assistant\",\n          content: content ? stringifyIfNeeded(content) : '',\n          toolCalls: message.tool_calls?.map((tc) => ({\n            id: tc.id!,\n            type: \"function\",\n            function: {\n              name: tc.name,\n              arguments: JSON.stringify(tc.args),\n            },\n          })),\n        };\n      case \"system\":\n        return {\n          id: message.id!,\n          role: \"system\",\n          content: stringifyIfNeeded(resolveMessageContent(message.content)),\n        };\n      case \"tool\":\n        return {\n          id: message.id!,\n          role: \"tool\",\n          content: stringifyIfNeeded(resolveMessageContent(message.content)),\n          toolCallId: message.tool_call_id,\n        };\n      default:\n        throw new Error(\"message type returned from LangGraph is not supported.\");\n    }\n  });\n}\n\nexport function aguiMessagesToLangChain(messages: Message[]): LangGraphMessage[] {\n  return messages.map((message, index) => {\n    switch (message.role) {\n      case \"user\":\n        return {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          type: \"human\",\n        };\n      case \"assistant\":\n        return {\n          id: message.id,\n          type: \"ai\",\n          role: message.role,\n          content: message.content ?? \"\",\n          tool_calls: (message.toolCalls ?? []).map((tc: ToolCall) => ({\n            id: tc.id,\n            name: tc.function.name,\n            args: JSON.parse(tc.function.arguments),\n            type: \"tool_call\",\n          })),\n        };\n      case \"system\":\n        return {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          type: \"system\",\n        };\n      case \"tool\":\n        return {\n          content: message.content,\n          role: message.role,\n          type: message.role,\n          tool_call_id: message.toolCallId,\n          id: message.id,\n        };\n      default:\n        console.error(`Message role ${message.role} is not implemented`);\n        throw new Error(\"message role is not supported.\");\n    }\n  });\n}\n\nfunction stringifyIfNeeded(item: any) {\n  if (typeof item === \"string\") return item;\n  return JSON.stringify(item);\n}\n\nexport function resolveReasoningContent(eventData: any): LangGraphReasoning | null {\n  const content = eventData.chunk?.content\n\n  // Anthropic reasoning response\n  if (content && Array.isArray(content) && content.length && content[0]) {\n    if (!content[0].thinking) return null\n    return {\n      text: content[0].thinking,\n      type: 'text',\n      index: content[0].index,\n    }\n  }\n\n  /// OpenAI reasoning response\n  if (eventData.chunk.additional_kwargs?.reasoning?.summary?.[0]) {\n    const data = eventData.chunk.additional_kwargs?.reasoning.summary[0]\n    if (!data || !data.text) return null\n    return {\n      type: 'text',\n      text: data.text,\n      index: data.index,\n    }\n  }\n\n  return null\n}\n\nexport function resolveMessageContent(content?: LangGraphMessage['content']): string | null {\n  if (!content) return null;\n\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (Array.isArray(content) && content.length) {\n    const contentText = content.find(c => c.type === 'text')?.text\n    return contentText ?? null;\n  }\n\n  return null\n}\n"],"mappings":"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","names":["index_exports","__export","CustomEventNames","LangGraphAgent","LangGraphEventTypes","LangGraphHttpAgent","__toCommonJS","import_client","import_rxjs","import_langgraph_sdk","import_node_crypto","import_messages","LangGraphEventTypes","CustomEventNames","import_client","DEFAULT_SCHEMA_KEYS","filterObjectBySchemaKeys","obj","schemaKeys","key","getStreamPayloadInput","mode","state","input","langchainMessagesToAgui","messages","message","_a","stringifyIfNeeded","resolveMessageContent","content","tc","aguiMessagesToLangChain","index","_b","item","resolveReasoningContent","eventData","_c","_d","_e","data","contentText","c","LangGraphAgent","config","_a","_b","LangGraphClient","__spreadValues","event","input","subscriber","_c","_d","_e","_f","_g","_h","_i","_j","_k","_l","_m","inputThreadId","state","messages","tools","context","forwardedProps","shouldExit","nodeNameInput","threadId","thread","agentState","agentStateValues","aguiToLangChainMessage","aguiMessagesToLangChain","graphInfo","mode","nodeBefore","e","payloadInput","getStreamPayloadInput","payloadConfig","configsToMerge","payload","__spreadProps","interrupts","interrupt","streamResponse","latestStateValues","updatedState","iter","__forAwait","more","temp","error","streamResponseChunk","chunk","chunkData","currentNodeName","eventType","metadata","node","tasks","isEndNode","writes","newNodeName","langchainMessagesToAgui","shouldEmitMessages","shouldEmitToolCalls","currentStream","hasCurrentStream","toolCallData","toolCallUsedToPredictState","predictStateTool","isToolCallStartEvent","isToolCallArgsEvent","isToolCallEndEvent","reasoningData","resolveReasoningContent","messageContent","resolveMessageContent","isMessageContentEvent","isMessageEndEvent","thinkingStepIndex","schemaKeys","filterObjectBySchemaKeys","DEFAULT_SCHEMA_KEYS","threadMetadata","configs","assistant","acc","cfg","filteredConfigurable","newConfig","isRecursionLimitSetToDefault","configsAreDifferent","isOnlyRecursionLimitDifferent","runId","data","assistants","retrievedAssistant","searchResult","a","CONSTANT_KEYS","graphSchema","configSchema","inputSchema","outputSchema","existingMessages","existingMessageIds","message","messageIds","removedMessages","m","newMessages","nodeName","LangGraphHttpAgent"]}