import {
  ActionExecutionMessage,
  AgentStateMessage,
  ImageMessage,
  ResultMessage,
  TextMessage
} from "./chunk-SHBDMA63.mjs";
import {
  EmptyAdapter,
  RemoteChain,
  streamLangChainResponse
} from "./chunk-QLLV2QVK.mjs";
import {
  GuardrailsValidationFailureResponse,
  MessageStreamInterruptedResponse,
  ResponseStatusUnion,
  SuccessResponseStatus,
  UnknownErrorResponse
} from "./chunk-XWBDEXDA.mjs";
import {
  BaseMessageInput
} from "./chunk-2OZAGFV3.mjs";
import {
  __commonJS,
  __name,
  __toESM
} from "./chunk-FHD4JECV.mjs";

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "@copilotkit/runtime",
      private: false,
      homepage: "https://github.com/CopilotKit/CopilotKit",
      repository: {
        type: "git",
        url: "https://github.com/CopilotKit/CopilotKit.git"
      },
      publishConfig: {
        access: "public"
      },
      version: "1.9.3",
      sideEffects: false,
      main: "./dist/index.js",
      module: "./dist/index.mjs",
      exports: {
        ".": "./dist/index.js"
      },
      types: "./dist/index.d.ts",
      license: "MIT",
      scripts: {
        build: 'tsup --onSuccess "pnpm run generate-graphql-schema"',
        dev: 'tsup --watch --onSuccess "pnpm run generate-graphql-schema"',
        test: "jest --passWithNoTests",
        "check-types": "tsc --noEmit",
        clean: "rm -rf .turbo && rm -rf node_modules && rm -rf dist && rm -rf .next && rm -rf __snapshots__",
        "generate-graphql-schema": "rm -rf __snapshots__ && ts-node ./scripts/generate-gql-schema.ts",
        "link:global": "pnpm link --global",
        "unlink:global": "pnpm unlink --global"
      },
      devDependencies: {
        "@jest/globals": "^29.7.0",
        "@swc/core": "1.5.28",
        "@types/express": "^4.17.21",
        "@types/jest": "^29.5.12",
        "@types/node": "^18.11.17",
        "@whatwg-node/server": "^0.9.34",
        eslint: "^8.56.0",
        "eslint-config-custom": "workspace:*",
        jest: "^29.6.4",
        nodemon: "^3.1.3",
        "ts-jest": "^29.1.1",
        "ts-node": "^10.9.2",
        tsconfig: "workspace:*",
        tsup: "^6.7.0",
        typescript: "^5.2.3",
        "zod-to-json-schema": "^3.23.5"
      },
      dependencies: {
        "@ag-ui/client": "0.0.35",
        "@ag-ui/core": "0.0.35",
        "@ag-ui/encoder": "0.0.35",
        "@ag-ui/langgraph": "0.0.7",
        "@ag-ui/proto": "0.0.35",
        "@anthropic-ai/sdk": "^0.27.3",
        "@copilotkit/shared": "workspace:*",
        "@graphql-yoga/plugin-defer-stream": "^3.3.1",
        "@langchain/aws": "^0.1.9",
        "@langchain/community": "^0.3.29",
        "@langchain/core": "^0.3.38",
        "@langchain/google-gauth": "^0.1.0",
        "@langchain/langgraph-sdk": "^0.0.70",
        "@langchain/openai": "^0.4.2",
        "@scarf/scarf": "^1.3.0",
        "@types/ip": "^1.1.3",
        "class-transformer": "^0.5.1",
        "class-validator": "^0.14.1",
        express: "^4.19.2",
        graphql: "^16.8.1",
        "graphql-scalars": "^1.23.0",
        "graphql-yoga": "^5.3.1",
        "groq-sdk": "^0.5.0",
        ip: "^2.0.1",
        langchain: "^0.3.3",
        openai: "^4.85.1",
        "partial-json": "^0.1.7",
        pino: "^9.2.0",
        "pino-pretty": "^11.2.1",
        "reflect-metadata": "^0.2.2",
        rxjs: "7.8.1",
        "type-graphql": "2.0.0-rc.1",
        zod: "^3.23.3"
      },
      peerDependencies: {
        "@ag-ui/client": ">=0.0.34",
        "@ag-ui/core": ">=0.0.34",
        "@ag-ui/encoder": ">=0.0.34",
        "@ag-ui/proto": ">=0.0.34"
      },
      keywords: [
        "copilotkit",
        "copilot",
        "react",
        "nextjs",
        "nodejs",
        "ai",
        "assistant",
        "javascript",
        "automation",
        "textarea"
      ]
    };
  }
});

// src/lib/integrations/node-http/index.ts
import { createYoga } from "graphql-yoga";

// src/lib/integrations/shared.ts
import { buildSchemaSync } from "type-graphql";

// src/graphql/resolvers/copilot.resolver.ts
import { Arg, Ctx, Mutation, Query, Resolver } from "type-graphql";
import { ReplaySubject as ReplaySubject3, Subject, filter, finalize, firstValueFrom as firstValueFrom2, shareReplay, skipWhile, take, takeWhile, tap } from "rxjs";

// src/graphql/inputs/generate-copilot-response.input.ts
import { Field as Field15, InputType as InputType11 } from "type-graphql";

// src/graphql/inputs/message.input.ts
import { Field, InputType } from "type-graphql";

// src/graphql/types/enums.ts
import { registerEnumType } from "type-graphql";
var MessageRole;
(function(MessageRole2) {
  MessageRole2["user"] = "user";
  MessageRole2["assistant"] = "assistant";
  MessageRole2["system"] = "system";
  MessageRole2["tool"] = "tool";
  MessageRole2["developer"] = "developer";
})(MessageRole || (MessageRole = {}));
var CopilotRequestType;
(function(CopilotRequestType2) {
  CopilotRequestType2["Chat"] = "Chat";
  CopilotRequestType2["Task"] = "Task";
  CopilotRequestType2["TextareaCompletion"] = "TextareaCompletion";
  CopilotRequestType2["TextareaPopover"] = "TextareaPopover";
  CopilotRequestType2["Suggestion"] = "Suggestion";
})(CopilotRequestType || (CopilotRequestType = {}));
var ActionInputAvailability;
(function(ActionInputAvailability2) {
  ActionInputAvailability2["disabled"] = "disabled";
  ActionInputAvailability2["enabled"] = "enabled";
  ActionInputAvailability2["remote"] = "remote";
})(ActionInputAvailability || (ActionInputAvailability = {}));
registerEnumType(MessageRole, {
  name: "MessageRole",
  description: "The role of the message"
});
registerEnumType(CopilotRequestType, {
  name: "CopilotRequestType",
  description: "The type of Copilot request"
});
registerEnumType(ActionInputAvailability, {
  name: "ActionInputAvailability",
  description: "The availability of the frontend action"
});

// src/graphql/inputs/message.input.ts
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
var MessageInput = class extends BaseMessageInput {
  textMessage;
  actionExecutionMessage;
  resultMessage;
  agentStateMessage;
  imageMessage;
};
__name(MessageInput, "MessageInput");
_ts_decorate([
  Field(() => TextMessageInput, {
    nullable: true
  }),
  _ts_metadata("design:type", typeof TextMessageInput === "undefined" ? Object : TextMessageInput)
], MessageInput.prototype, "textMessage", void 0);
_ts_decorate([
  Field(() => ActionExecutionMessageInput, {
    nullable: true
  }),
  _ts_metadata("design:type", typeof ActionExecutionMessageInput === "undefined" ? Object : ActionExecutionMessageInput)
], MessageInput.prototype, "actionExecutionMessage", void 0);
_ts_decorate([
  Field(() => ResultMessageInput, {
    nullable: true
  }),
  _ts_metadata("design:type", typeof ResultMessageInput === "undefined" ? Object : ResultMessageInput)
], MessageInput.prototype, "resultMessage", void 0);
_ts_decorate([
  Field(() => AgentStateMessageInput, {
    nullable: true
  }),
  _ts_metadata("design:type", typeof AgentStateMessageInput === "undefined" ? Object : AgentStateMessageInput)
], MessageInput.prototype, "agentStateMessage", void 0);
_ts_decorate([
  Field(() => ImageMessageInput, {
    nullable: true
  }),
  _ts_metadata("design:type", typeof ImageMessageInput === "undefined" ? Object : ImageMessageInput)
], MessageInput.prototype, "imageMessage", void 0);
MessageInput = _ts_decorate([
  InputType()
], MessageInput);
var TextMessageInput = class {
  content;
  parentMessageId;
  role;
};
__name(TextMessageInput, "TextMessageInput");
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], TextMessageInput.prototype, "content", void 0);
_ts_decorate([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata("design:type", String)
], TextMessageInput.prototype, "parentMessageId", void 0);
_ts_decorate([
  Field(() => MessageRole),
  _ts_metadata("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], TextMessageInput.prototype, "role", void 0);
TextMessageInput = _ts_decorate([
  InputType()
], TextMessageInput);
var ActionExecutionMessageInput = class {
  name;
  arguments;
  parentMessageId;
  scope;
};
__name(ActionExecutionMessageInput, "ActionExecutionMessageInput");
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], ActionExecutionMessageInput.prototype, "name", void 0);
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], ActionExecutionMessageInput.prototype, "arguments", void 0);
_ts_decorate([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata("design:type", String)
], ActionExecutionMessageInput.prototype, "parentMessageId", void 0);
_ts_decorate([
  Field(() => String, {
    nullable: true,
    deprecationReason: "This field will be removed in a future version"
  }),
  _ts_metadata("design:type", typeof String === "undefined" ? Object : String)
], ActionExecutionMessageInput.prototype, "scope", void 0);
ActionExecutionMessageInput = _ts_decorate([
  InputType()
], ActionExecutionMessageInput);
var ResultMessageInput = class {
  actionExecutionId;
  actionName;
  parentMessageId;
  result;
};
__name(ResultMessageInput, "ResultMessageInput");
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], ResultMessageInput.prototype, "actionExecutionId", void 0);
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], ResultMessageInput.prototype, "actionName", void 0);
_ts_decorate([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata("design:type", String)
], ResultMessageInput.prototype, "parentMessageId", void 0);
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], ResultMessageInput.prototype, "result", void 0);
ResultMessageInput = _ts_decorate([
  InputType()
], ResultMessageInput);
var AgentStateMessageInput = class {
  threadId;
  agentName;
  role;
  state;
  running;
  nodeName;
  runId;
  active;
};
__name(AgentStateMessageInput, "AgentStateMessageInput");
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], AgentStateMessageInput.prototype, "threadId", void 0);
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], AgentStateMessageInput.prototype, "agentName", void 0);
_ts_decorate([
  Field(() => MessageRole),
  _ts_metadata("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], AgentStateMessageInput.prototype, "role", void 0);
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], AgentStateMessageInput.prototype, "state", void 0);
_ts_decorate([
  Field(() => Boolean),
  _ts_metadata("design:type", Boolean)
], AgentStateMessageInput.prototype, "running", void 0);
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], AgentStateMessageInput.prototype, "nodeName", void 0);
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], AgentStateMessageInput.prototype, "runId", void 0);
_ts_decorate([
  Field(() => Boolean),
  _ts_metadata("design:type", Boolean)
], AgentStateMessageInput.prototype, "active", void 0);
AgentStateMessageInput = _ts_decorate([
  InputType()
], AgentStateMessageInput);
var ImageMessageInput = class {
  format;
  bytes;
  parentMessageId;
  role;
};
__name(ImageMessageInput, "ImageMessageInput");
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], ImageMessageInput.prototype, "format", void 0);
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], ImageMessageInput.prototype, "bytes", void 0);
_ts_decorate([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata("design:type", String)
], ImageMessageInput.prototype, "parentMessageId", void 0);
_ts_decorate([
  Field(() => MessageRole),
  _ts_metadata("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], ImageMessageInput.prototype, "role", void 0);
ImageMessageInput = _ts_decorate([
  InputType()
], ImageMessageInput);

// src/graphql/inputs/frontend.input.ts
import { Field as Field3, InputType as InputType3 } from "type-graphql";

// src/graphql/inputs/action.input.ts
import { Field as Field2, InputType as InputType2 } from "type-graphql";
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate2, "_ts_decorate");
function _ts_metadata2(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata2, "_ts_metadata");
var ActionInput = class {
  name;
  description;
  jsonSchema;
  available;
};
__name(ActionInput, "ActionInput");
_ts_decorate2([
  Field2(() => String),
  _ts_metadata2("design:type", String)
], ActionInput.prototype, "name", void 0);
_ts_decorate2([
  Field2(() => String),
  _ts_metadata2("design:type", String)
], ActionInput.prototype, "description", void 0);
_ts_decorate2([
  Field2(() => String),
  _ts_metadata2("design:type", String)
], ActionInput.prototype, "jsonSchema", void 0);
_ts_decorate2([
  Field2(() => ActionInputAvailability, {
    nullable: true
  }),
  _ts_metadata2("design:type", typeof ActionInputAvailability === "undefined" ? Object : ActionInputAvailability)
], ActionInput.prototype, "available", void 0);
ActionInput = _ts_decorate2([
  InputType2()
], ActionInput);

// src/graphql/inputs/frontend.input.ts
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate3, "_ts_decorate");
function _ts_metadata3(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata3, "_ts_metadata");
var FrontendInput = class {
  toDeprecate_fullContext;
  actions;
  url;
};
__name(FrontendInput, "FrontendInput");
_ts_decorate3([
  Field3(() => String, {
    nullable: true
  }),
  _ts_metadata3("design:type", String)
], FrontendInput.prototype, "toDeprecate_fullContext", void 0);
_ts_decorate3([
  Field3(() => [
    ActionInput
  ]),
  _ts_metadata3("design:type", Array)
], FrontendInput.prototype, "actions", void 0);
_ts_decorate3([
  Field3(() => String, {
    nullable: true
  }),
  _ts_metadata3("design:type", String)
], FrontendInput.prototype, "url", void 0);
FrontendInput = _ts_decorate3([
  InputType3()
], FrontendInput);

// src/graphql/inputs/cloud.input.ts
import { Field as Field5, InputType as InputType5 } from "type-graphql";

// src/graphql/inputs/cloud-guardrails.input.ts
import { Field as Field4, InputType as InputType4 } from "type-graphql";
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate4, "_ts_decorate");
function _ts_metadata4(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata4, "_ts_metadata");
var GuardrailsRuleInput = class {
  allowList = [];
  denyList = [];
};
__name(GuardrailsRuleInput, "GuardrailsRuleInput");
_ts_decorate4([
  Field4(() => [
    String
  ], {
    nullable: true
  }),
  _ts_metadata4("design:type", Array)
], GuardrailsRuleInput.prototype, "allowList", void 0);
_ts_decorate4([
  Field4(() => [
    String
  ], {
    nullable: true
  }),
  _ts_metadata4("design:type", Array)
], GuardrailsRuleInput.prototype, "denyList", void 0);
GuardrailsRuleInput = _ts_decorate4([
  InputType4()
], GuardrailsRuleInput);
var GuardrailsInput = class {
  inputValidationRules;
};
__name(GuardrailsInput, "GuardrailsInput");
_ts_decorate4([
  Field4(() => GuardrailsRuleInput, {
    nullable: false
  }),
  _ts_metadata4("design:type", typeof GuardrailsRuleInput === "undefined" ? Object : GuardrailsRuleInput)
], GuardrailsInput.prototype, "inputValidationRules", void 0);
GuardrailsInput = _ts_decorate4([
  InputType4()
], GuardrailsInput);

// src/graphql/inputs/cloud.input.ts
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate5, "_ts_decorate");
function _ts_metadata5(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata5, "_ts_metadata");
var CloudInput = class {
  guardrails;
};
__name(CloudInput, "CloudInput");
_ts_decorate5([
  Field5(() => GuardrailsInput, {
    nullable: true
  }),
  _ts_metadata5("design:type", typeof GuardrailsInput === "undefined" ? Object : GuardrailsInput)
], CloudInput.prototype, "guardrails", void 0);
CloudInput = _ts_decorate5([
  InputType5()
], CloudInput);

// src/graphql/inputs/forwarded-parameters.input.ts
import { Field as Field6, InputType as InputType6 } from "type-graphql";
function _ts_decorate6(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate6, "_ts_decorate");
function _ts_metadata6(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata6, "_ts_metadata");
var ForwardedParametersInput = class {
  model;
  maxTokens;
  stop;
  toolChoice;
  toolChoiceFunctionName;
  temperature;
};
__name(ForwardedParametersInput, "ForwardedParametersInput");
_ts_decorate6([
  Field6(() => String, {
    nullable: true
  }),
  _ts_metadata6("design:type", String)
], ForwardedParametersInput.prototype, "model", void 0);
_ts_decorate6([
  Field6(() => Number, {
    nullable: true
  }),
  _ts_metadata6("design:type", Number)
], ForwardedParametersInput.prototype, "maxTokens", void 0);
_ts_decorate6([
  Field6(() => [
    String
  ], {
    nullable: true
  }),
  _ts_metadata6("design:type", Array)
], ForwardedParametersInput.prototype, "stop", void 0);
_ts_decorate6([
  Field6(() => String, {
    nullable: true
  }),
  _ts_metadata6("design:type", typeof String === "undefined" ? Object : String)
], ForwardedParametersInput.prototype, "toolChoice", void 0);
_ts_decorate6([
  Field6(() => String, {
    nullable: true
  }),
  _ts_metadata6("design:type", String)
], ForwardedParametersInput.prototype, "toolChoiceFunctionName", void 0);
_ts_decorate6([
  Field6(() => Number, {
    nullable: true
  }),
  _ts_metadata6("design:type", Number)
], ForwardedParametersInput.prototype, "temperature", void 0);
ForwardedParametersInput = _ts_decorate6([
  InputType6()
], ForwardedParametersInput);

// src/graphql/inputs/agent-session.input.ts
import { Field as Field7, InputType as InputType7 } from "type-graphql";
function _ts_decorate7(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate7, "_ts_decorate");
function _ts_metadata7(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata7, "_ts_metadata");
var AgentSessionInput = class {
  agentName;
  threadId;
  nodeName;
};
__name(AgentSessionInput, "AgentSessionInput");
_ts_decorate7([
  Field7(() => String),
  _ts_metadata7("design:type", String)
], AgentSessionInput.prototype, "agentName", void 0);
_ts_decorate7([
  Field7(() => String, {
    nullable: true
  }),
  _ts_metadata7("design:type", String)
], AgentSessionInput.prototype, "threadId", void 0);
_ts_decorate7([
  Field7(() => String, {
    nullable: true
  }),
  _ts_metadata7("design:type", String)
], AgentSessionInput.prototype, "nodeName", void 0);
AgentSessionInput = _ts_decorate7([
  InputType7()
], AgentSessionInput);

// src/graphql/inputs/agent-state.input.ts
import { Field as Field8, InputType as InputType8 } from "type-graphql";
function _ts_decorate8(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate8, "_ts_decorate");
function _ts_metadata8(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata8, "_ts_metadata");
var AgentStateInput = class {
  agentName;
  state;
  config;
};
__name(AgentStateInput, "AgentStateInput");
_ts_decorate8([
  Field8(() => String),
  _ts_metadata8("design:type", String)
], AgentStateInput.prototype, "agentName", void 0);
_ts_decorate8([
  Field8(() => String),
  _ts_metadata8("design:type", String)
], AgentStateInput.prototype, "state", void 0);
_ts_decorate8([
  Field8(() => String, {
    nullable: true
  }),
  _ts_metadata8("design:type", String)
], AgentStateInput.prototype, "config", void 0);
AgentStateInput = _ts_decorate8([
  InputType8()
], AgentStateInput);

// src/graphql/inputs/extensions.input.ts
import { Field as Field9, InputType as InputType9 } from "type-graphql";
function _ts_decorate9(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate9, "_ts_decorate");
function _ts_metadata9(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata9, "_ts_metadata");
var ExtensionsInput = class {
  openaiAssistantAPI;
};
__name(ExtensionsInput, "ExtensionsInput");
_ts_decorate9([
  Field9(() => OpenAIApiAssistantAPIInput, {
    nullable: true
  }),
  _ts_metadata9("design:type", typeof OpenAIApiAssistantAPIInput === "undefined" ? Object : OpenAIApiAssistantAPIInput)
], ExtensionsInput.prototype, "openaiAssistantAPI", void 0);
ExtensionsInput = _ts_decorate9([
  InputType9()
], ExtensionsInput);
var OpenAIApiAssistantAPIInput = class {
  runId;
  threadId;
};
__name(OpenAIApiAssistantAPIInput, "OpenAIApiAssistantAPIInput");
_ts_decorate9([
  Field9(() => String, {
    nullable: true
  }),
  _ts_metadata9("design:type", String)
], OpenAIApiAssistantAPIInput.prototype, "runId", void 0);
_ts_decorate9([
  Field9(() => String, {
    nullable: true
  }),
  _ts_metadata9("design:type", String)
], OpenAIApiAssistantAPIInput.prototype, "threadId", void 0);
OpenAIApiAssistantAPIInput = _ts_decorate9([
  InputType9()
], OpenAIApiAssistantAPIInput);

// src/graphql/inputs/meta-event.input.ts
import { Field as Field14, InputType as InputType10 } from "type-graphql";

// src/graphql/types/meta-events.type.ts
import { Field as Field13, InterfaceType as InterfaceType2, ObjectType as ObjectType4, registerEnumType as registerEnumType3 } from "type-graphql";

// src/graphql/types/copilot-response.type.ts
import { Field as Field12, InterfaceType, ObjectType as ObjectType3 } from "type-graphql";

// src/graphql/types/message-status.type.ts
import { Field as Field10, ObjectType, createUnionType, registerEnumType as registerEnumType2 } from "type-graphql";
function _ts_decorate10(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate10, "_ts_decorate");
function _ts_metadata10(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata10, "_ts_metadata");
var MessageStatusCode;
(function(MessageStatusCode2) {
  MessageStatusCode2["Pending"] = "pending";
  MessageStatusCode2["Success"] = "success";
  MessageStatusCode2["Failed"] = "failed";
})(MessageStatusCode || (MessageStatusCode = {}));
registerEnumType2(MessageStatusCode, {
  name: "MessageStatusCode"
});
var BaseMessageStatus = /* @__PURE__ */ __name(class BaseMessageStatus2 {
  code;
}, "BaseMessageStatus");
_ts_decorate10([
  Field10(() => MessageStatusCode),
  _ts_metadata10("design:type", String)
], BaseMessageStatus.prototype, "code", void 0);
BaseMessageStatus = _ts_decorate10([
  ObjectType()
], BaseMessageStatus);
var PendingMessageStatus = class extends BaseMessageStatus {
  code = "pending";
};
__name(PendingMessageStatus, "PendingMessageStatus");
PendingMessageStatus = _ts_decorate10([
  ObjectType()
], PendingMessageStatus);
var SuccessMessageStatus = class extends BaseMessageStatus {
  code = "success";
};
__name(SuccessMessageStatus, "SuccessMessageStatus");
SuccessMessageStatus = _ts_decorate10([
  ObjectType()
], SuccessMessageStatus);
var FailedMessageStatus = class extends BaseMessageStatus {
  code = "failed";
  reason;
};
__name(FailedMessageStatus, "FailedMessageStatus");
_ts_decorate10([
  Field10(() => String),
  _ts_metadata10("design:type", String)
], FailedMessageStatus.prototype, "reason", void 0);
FailedMessageStatus = _ts_decorate10([
  ObjectType()
], FailedMessageStatus);
var MessageStatusUnion = createUnionType({
  name: "MessageStatus",
  types: () => [
    PendingMessageStatus,
    SuccessMessageStatus,
    FailedMessageStatus
  ]
});

// src/graphql/types/extensions-response.type.ts
import { Field as Field11, ObjectType as ObjectType2 } from "type-graphql";
function _ts_decorate11(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate11, "_ts_decorate");
function _ts_metadata11(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata11, "_ts_metadata");
var ExtensionsResponse = class {
  openaiAssistantAPI;
};
__name(ExtensionsResponse, "ExtensionsResponse");
_ts_decorate11([
  Field11(() => OpenAIApiAssistantAPIResponse, {
    nullable: true
  }),
  _ts_metadata11("design:type", typeof OpenAIApiAssistantAPIResponse === "undefined" ? Object : OpenAIApiAssistantAPIResponse)
], ExtensionsResponse.prototype, "openaiAssistantAPI", void 0);
ExtensionsResponse = _ts_decorate11([
  ObjectType2()
], ExtensionsResponse);
var OpenAIApiAssistantAPIResponse = class {
  runId;
  threadId;
};
__name(OpenAIApiAssistantAPIResponse, "OpenAIApiAssistantAPIResponse");
_ts_decorate11([
  Field11(() => String, {
    nullable: true
  }),
  _ts_metadata11("design:type", String)
], OpenAIApiAssistantAPIResponse.prototype, "runId", void 0);
_ts_decorate11([
  Field11(() => String, {
    nullable: true
  }),
  _ts_metadata11("design:type", String)
], OpenAIApiAssistantAPIResponse.prototype, "threadId", void 0);
OpenAIApiAssistantAPIResponse = _ts_decorate11([
  ObjectType2()
], OpenAIApiAssistantAPIResponse);

// src/graphql/types/copilot-response.type.ts
function _ts_decorate12(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate12, "_ts_decorate");
function _ts_metadata12(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata12, "_ts_metadata");
var BaseMessageOutput = class {
  id;
  createdAt;
  status;
};
__name(BaseMessageOutput, "BaseMessageOutput");
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], BaseMessageOutput.prototype, "id", void 0);
_ts_decorate12([
  Field12(() => Date),
  _ts_metadata12("design:type", typeof Date === "undefined" ? Object : Date)
], BaseMessageOutput.prototype, "createdAt", void 0);
_ts_decorate12([
  Field12(() => MessageStatusUnion),
  _ts_metadata12("design:type", Object)
], BaseMessageOutput.prototype, "status", void 0);
BaseMessageOutput = _ts_decorate12([
  InterfaceType({
    resolveType(value) {
      if (value.hasOwnProperty("content")) {
        return TextMessageOutput;
      } else if (value.hasOwnProperty("name")) {
        return ActionExecutionMessageOutput;
      } else if (value.hasOwnProperty("result")) {
        return ResultMessageOutput;
      } else if (value.hasOwnProperty("state")) {
        return AgentStateMessageOutput;
      } else if (value.hasOwnProperty("format") && value.hasOwnProperty("bytes")) {
        return ImageMessageOutput;
      }
      return void 0;
    }
  })
], BaseMessageOutput);
var TextMessageOutput = class {
  role;
  content;
  parentMessageId;
};
__name(TextMessageOutput, "TextMessageOutput");
_ts_decorate12([
  Field12(() => MessageRole),
  _ts_metadata12("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], TextMessageOutput.prototype, "role", void 0);
_ts_decorate12([
  Field12(() => [
    String
  ]),
  _ts_metadata12("design:type", Array)
], TextMessageOutput.prototype, "content", void 0);
_ts_decorate12([
  Field12(() => String, {
    nullable: true
  }),
  _ts_metadata12("design:type", String)
], TextMessageOutput.prototype, "parentMessageId", void 0);
TextMessageOutput = _ts_decorate12([
  ObjectType3({
    implements: BaseMessageOutput
  })
], TextMessageOutput);
var ActionExecutionMessageOutput = class {
  name;
  scope;
  arguments;
  parentMessageId;
};
__name(ActionExecutionMessageOutput, "ActionExecutionMessageOutput");
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], ActionExecutionMessageOutput.prototype, "name", void 0);
_ts_decorate12([
  Field12(() => String, {
    nullable: true,
    deprecationReason: "This field will be removed in a future version"
  }),
  _ts_metadata12("design:type", String)
], ActionExecutionMessageOutput.prototype, "scope", void 0);
_ts_decorate12([
  Field12(() => [
    String
  ]),
  _ts_metadata12("design:type", Array)
], ActionExecutionMessageOutput.prototype, "arguments", void 0);
_ts_decorate12([
  Field12(() => String, {
    nullable: true
  }),
  _ts_metadata12("design:type", String)
], ActionExecutionMessageOutput.prototype, "parentMessageId", void 0);
ActionExecutionMessageOutput = _ts_decorate12([
  ObjectType3({
    implements: BaseMessageOutput
  })
], ActionExecutionMessageOutput);
var ResultMessageOutput = class {
  actionExecutionId;
  actionName;
  result;
};
__name(ResultMessageOutput, "ResultMessageOutput");
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], ResultMessageOutput.prototype, "actionExecutionId", void 0);
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], ResultMessageOutput.prototype, "actionName", void 0);
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], ResultMessageOutput.prototype, "result", void 0);
ResultMessageOutput = _ts_decorate12([
  ObjectType3({
    implements: BaseMessageOutput
  })
], ResultMessageOutput);
var AgentStateMessageOutput = class {
  threadId;
  agentName;
  nodeName;
  runId;
  active;
  role;
  state;
  running;
};
__name(AgentStateMessageOutput, "AgentStateMessageOutput");
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], AgentStateMessageOutput.prototype, "threadId", void 0);
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], AgentStateMessageOutput.prototype, "agentName", void 0);
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], AgentStateMessageOutput.prototype, "nodeName", void 0);
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], AgentStateMessageOutput.prototype, "runId", void 0);
_ts_decorate12([
  Field12(() => Boolean),
  _ts_metadata12("design:type", Boolean)
], AgentStateMessageOutput.prototype, "active", void 0);
_ts_decorate12([
  Field12(() => MessageRole),
  _ts_metadata12("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], AgentStateMessageOutput.prototype, "role", void 0);
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], AgentStateMessageOutput.prototype, "state", void 0);
_ts_decorate12([
  Field12(() => Boolean),
  _ts_metadata12("design:type", Boolean)
], AgentStateMessageOutput.prototype, "running", void 0);
AgentStateMessageOutput = _ts_decorate12([
  ObjectType3({
    implements: BaseMessageOutput
  })
], AgentStateMessageOutput);
var ImageMessageOutput = class {
  format;
  bytes;
  role;
  parentMessageId;
};
__name(ImageMessageOutput, "ImageMessageOutput");
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], ImageMessageOutput.prototype, "format", void 0);
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], ImageMessageOutput.prototype, "bytes", void 0);
_ts_decorate12([
  Field12(() => MessageRole),
  _ts_metadata12("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], ImageMessageOutput.prototype, "role", void 0);
_ts_decorate12([
  Field12(() => String, {
    nullable: true
  }),
  _ts_metadata12("design:type", String)
], ImageMessageOutput.prototype, "parentMessageId", void 0);
ImageMessageOutput = _ts_decorate12([
  ObjectType3({
    implements: BaseMessageOutput
  })
], ImageMessageOutput);
var CopilotResponse = class {
  threadId;
  status;
  runId;
  messages;
  extensions;
  metaEvents;
};
__name(CopilotResponse, "CopilotResponse");
_ts_decorate12([
  Field12(() => String),
  _ts_metadata12("design:type", String)
], CopilotResponse.prototype, "threadId", void 0);
_ts_decorate12([
  Field12(() => ResponseStatusUnion),
  _ts_metadata12("design:type", Object)
], CopilotResponse.prototype, "status", void 0);
_ts_decorate12([
  Field12({
    nullable: true
  }),
  _ts_metadata12("design:type", String)
], CopilotResponse.prototype, "runId", void 0);
_ts_decorate12([
  Field12(() => [
    BaseMessageOutput
  ]),
  _ts_metadata12("design:type", Array)
], CopilotResponse.prototype, "messages", void 0);
_ts_decorate12([
  Field12(() => ExtensionsResponse, {
    nullable: true
  }),
  _ts_metadata12("design:type", typeof ExtensionsResponse === "undefined" ? Object : ExtensionsResponse)
], CopilotResponse.prototype, "extensions", void 0);
_ts_decorate12([
  Field12(() => [
    BaseMetaEvent
  ], {
    nullable: true
  }),
  _ts_metadata12("design:type", Array)
], CopilotResponse.prototype, "metaEvents", void 0);
CopilotResponse = _ts_decorate12([
  ObjectType3()
], CopilotResponse);

// src/graphql/types/meta-events.type.ts
function _ts_decorate13(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate13, "_ts_decorate");
function _ts_metadata13(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata13, "_ts_metadata");
var MetaEventName;
(function(MetaEventName2) {
  MetaEventName2["LangGraphInterruptEvent"] = "LangGraphInterruptEvent";
  MetaEventName2["CopilotKitLangGraphInterruptEvent"] = "CopilotKitLangGraphInterruptEvent";
})(MetaEventName || (MetaEventName = {}));
registerEnumType3(MetaEventName, {
  name: "MetaEventName",
  description: "Meta event types"
});
var BaseMetaEvent = class {
  type = "MetaEvent";
  name;
};
__name(BaseMetaEvent, "BaseMetaEvent");
_ts_decorate13([
  Field13(() => String),
  _ts_metadata13("design:type", String)
], BaseMetaEvent.prototype, "type", void 0);
_ts_decorate13([
  Field13(() => MetaEventName),
  _ts_metadata13("design:type", String)
], BaseMetaEvent.prototype, "name", void 0);
BaseMetaEvent = _ts_decorate13([
  InterfaceType2({
    resolveType(value) {
      if (value.name === "LangGraphInterruptEvent") {
        return LangGraphInterruptEvent;
      } else if (value.name === "CopilotKitLangGraphInterruptEvent") {
        return CopilotKitLangGraphInterruptEvent;
      }
      return void 0;
    }
  }),
  InterfaceType2()
], BaseMetaEvent);
var CopilotKitLangGraphInterruptEventData = class {
  value;
  messages;
};
__name(CopilotKitLangGraphInterruptEventData, "CopilotKitLangGraphInterruptEventData");
_ts_decorate13([
  Field13(() => String),
  _ts_metadata13("design:type", String)
], CopilotKitLangGraphInterruptEventData.prototype, "value", void 0);
_ts_decorate13([
  Field13(() => [
    BaseMessageOutput
  ]),
  _ts_metadata13("design:type", Array)
], CopilotKitLangGraphInterruptEventData.prototype, "messages", void 0);
CopilotKitLangGraphInterruptEventData = _ts_decorate13([
  ObjectType4()
], CopilotKitLangGraphInterruptEventData);
var LangGraphInterruptEvent = class {
  name = "LangGraphInterruptEvent";
  value;
  response;
};
__name(LangGraphInterruptEvent, "LangGraphInterruptEvent");
_ts_decorate13([
  Field13(() => MetaEventName),
  _ts_metadata13("design:type", typeof MetaEventName === "undefined" || false ? Object : "LangGraphInterruptEvent")
], LangGraphInterruptEvent.prototype, "name", void 0);
_ts_decorate13([
  Field13(() => String),
  _ts_metadata13("design:type", String)
], LangGraphInterruptEvent.prototype, "value", void 0);
_ts_decorate13([
  Field13(() => String, {
    nullable: true
  }),
  _ts_metadata13("design:type", String)
], LangGraphInterruptEvent.prototype, "response", void 0);
LangGraphInterruptEvent = _ts_decorate13([
  ObjectType4({
    implements: BaseMetaEvent
  })
], LangGraphInterruptEvent);
var CopilotKitLangGraphInterruptEvent = class {
  name = "CopilotKitLangGraphInterruptEvent";
  data;
  response;
};
__name(CopilotKitLangGraphInterruptEvent, "CopilotKitLangGraphInterruptEvent");
_ts_decorate13([
  Field13(() => MetaEventName),
  _ts_metadata13("design:type", typeof MetaEventName === "undefined" || false ? Object : "CopilotKitLangGraphInterruptEvent")
], CopilotKitLangGraphInterruptEvent.prototype, "name", void 0);
_ts_decorate13([
  Field13(() => CopilotKitLangGraphInterruptEventData),
  _ts_metadata13("design:type", typeof CopilotKitLangGraphInterruptEventData === "undefined" ? Object : CopilotKitLangGraphInterruptEventData)
], CopilotKitLangGraphInterruptEvent.prototype, "data", void 0);
_ts_decorate13([
  Field13(() => String, {
    nullable: true
  }),
  _ts_metadata13("design:type", String)
], CopilotKitLangGraphInterruptEvent.prototype, "response", void 0);
CopilotKitLangGraphInterruptEvent = _ts_decorate13([
  ObjectType4({
    implements: BaseMetaEvent
  })
], CopilotKitLangGraphInterruptEvent);

// src/graphql/inputs/meta-event.input.ts
function _ts_decorate14(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate14, "_ts_decorate");
function _ts_metadata14(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata14, "_ts_metadata");
var MetaEventInput = class {
  name;
  value;
  response;
  messages;
};
__name(MetaEventInput, "MetaEventInput");
_ts_decorate14([
  Field14(() => MetaEventName),
  _ts_metadata14("design:type", typeof MetaEventName === "undefined" ? Object : MetaEventName)
], MetaEventInput.prototype, "name", void 0);
_ts_decorate14([
  Field14(() => String),
  _ts_metadata14("design:type", String)
], MetaEventInput.prototype, "value", void 0);
_ts_decorate14([
  Field14(() => String, {
    nullable: true
  }),
  _ts_metadata14("design:type", String)
], MetaEventInput.prototype, "response", void 0);
_ts_decorate14([
  Field14(() => [
    MessageInput
  ], {
    nullable: true
  }),
  _ts_metadata14("design:type", Array)
], MetaEventInput.prototype, "messages", void 0);
MetaEventInput = _ts_decorate14([
  InputType10()
], MetaEventInput);

// src/graphql/inputs/generate-copilot-response.input.ts
function _ts_decorate15(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate15, "_ts_decorate");
function _ts_metadata15(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata15, "_ts_metadata");
var GenerateCopilotResponseMetadataInput = class {
  requestType;
};
__name(GenerateCopilotResponseMetadataInput, "GenerateCopilotResponseMetadataInput");
_ts_decorate15([
  Field15(() => CopilotRequestType, {
    nullable: true
  }),
  _ts_metadata15("design:type", typeof CopilotRequestType === "undefined" ? Object : CopilotRequestType)
], GenerateCopilotResponseMetadataInput.prototype, "requestType", void 0);
GenerateCopilotResponseMetadataInput = _ts_decorate15([
  InputType11()
], GenerateCopilotResponseMetadataInput);
var GenerateCopilotResponseInput = class {
  metadata;
  threadId;
  runId;
  messages;
  frontend;
  cloud;
  forwardedParameters;
  agentSession;
  agentState;
  agentStates;
  extensions;
  metaEvents;
};
__name(GenerateCopilotResponseInput, "GenerateCopilotResponseInput");
_ts_decorate15([
  Field15(() => GenerateCopilotResponseMetadataInput, {
    nullable: false
  }),
  _ts_metadata15("design:type", typeof GenerateCopilotResponseMetadataInput === "undefined" ? Object : GenerateCopilotResponseMetadataInput)
], GenerateCopilotResponseInput.prototype, "metadata", void 0);
_ts_decorate15([
  Field15(() => String, {
    nullable: true
  }),
  _ts_metadata15("design:type", String)
], GenerateCopilotResponseInput.prototype, "threadId", void 0);
_ts_decorate15([
  Field15(() => String, {
    nullable: true
  }),
  _ts_metadata15("design:type", String)
], GenerateCopilotResponseInput.prototype, "runId", void 0);
_ts_decorate15([
  Field15(() => [
    MessageInput
  ]),
  _ts_metadata15("design:type", Array)
], GenerateCopilotResponseInput.prototype, "messages", void 0);
_ts_decorate15([
  Field15(() => FrontendInput),
  _ts_metadata15("design:type", typeof FrontendInput === "undefined" ? Object : FrontendInput)
], GenerateCopilotResponseInput.prototype, "frontend", void 0);
_ts_decorate15([
  Field15(() => CloudInput, {
    nullable: true
  }),
  _ts_metadata15("design:type", typeof CloudInput === "undefined" ? Object : CloudInput)
], GenerateCopilotResponseInput.prototype, "cloud", void 0);
_ts_decorate15([
  Field15(() => ForwardedParametersInput, {
    nullable: true
  }),
  _ts_metadata15("design:type", typeof ForwardedParametersInput === "undefined" ? Object : ForwardedParametersInput)
], GenerateCopilotResponseInput.prototype, "forwardedParameters", void 0);
_ts_decorate15([
  Field15(() => AgentSessionInput, {
    nullable: true
  }),
  _ts_metadata15("design:type", typeof AgentSessionInput === "undefined" ? Object : AgentSessionInput)
], GenerateCopilotResponseInput.prototype, "agentSession", void 0);
_ts_decorate15([
  Field15(() => AgentStateInput, {
    nullable: true
  }),
  _ts_metadata15("design:type", typeof AgentStateInput === "undefined" ? Object : AgentStateInput)
], GenerateCopilotResponseInput.prototype, "agentState", void 0);
_ts_decorate15([
  Field15(() => [
    AgentStateInput
  ], {
    nullable: true
  }),
  _ts_metadata15("design:type", Array)
], GenerateCopilotResponseInput.prototype, "agentStates", void 0);
_ts_decorate15([
  Field15(() => ExtensionsInput, {
    nullable: true
  }),
  _ts_metadata15("design:type", typeof ExtensionsInput === "undefined" ? Object : ExtensionsInput)
], GenerateCopilotResponseInput.prototype, "extensions", void 0);
_ts_decorate15([
  Field15(() => [
    MetaEventInput
  ], {
    nullable: true
  }),
  _ts_metadata15("design:type", Array)
], GenerateCopilotResponseInput.prototype, "metaEvents", void 0);
GenerateCopilotResponseInput = _ts_decorate15([
  InputType11()
], GenerateCopilotResponseInput);

// src/graphql/resolvers/copilot.resolver.ts
import { Repeater } from "graphql-yoga";

// src/service-adapters/events.ts
import { CopilotKitError as CopilotKitError6, CopilotKitErrorCode as CopilotKitErrorCode4, CopilotKitLowLevelError as CopilotKitLowLevelError7, ensureStructuredError as ensureStructuredError3, randomId as randomId2, Severity } from "@copilotkit/shared";
import { plainToInstance as plainToInstance2 } from "class-transformer";
import { catchError as catchError2, concat, concatMap, EMPTY, firstValueFrom, from as from2, of, ReplaySubject as ReplaySubject2, scan as scan2 } from "rxjs";

// src/lib/runtime/remote-actions.ts
import { CopilotKitErrorCode as CopilotKitErrorCode3 } from "@copilotkit/shared";

// src/lib/runtime/remote-action-constructors.ts
import { createHash as createHash3 } from "crypto";

// src/lib/telemetry-client.ts
import { TelemetryClient } from "@copilotkit/shared";
import { createHash as createHash2 } from "crypto";

// src/lib/runtime/copilot-runtime.ts
import { actionParametersToJsonSchema, ResolvedCopilotKitError, CopilotKitApiDiscoveryError, randomId, CopilotKitError as CopilotKitError3, CopilotKitAgentDiscoveryError, CopilotKitMisuseError as CopilotKitMisuseError2, CopilotKitErrorCode as CopilotKitErrorCode2, CopilotKitLowLevelError as CopilotKitLowLevelError3, ensureStructuredError as ensureStructuredError2 } from "@copilotkit/shared";

// src/service-adapters/conversion.ts
import { plainToInstance } from "class-transformer";
import { tryMap } from "@copilotkit/shared";
function convertGqlInputToMessages(inputMessages) {
  const messages = tryMap(inputMessages, (message) => {
    if (message.textMessage) {
      return plainToInstance(TextMessage, {
        id: message.id,
        createdAt: message.createdAt,
        role: message.textMessage.role,
        content: message.textMessage.content,
        parentMessageId: message.textMessage.parentMessageId
      });
    } else if (message.imageMessage) {
      return plainToInstance(ImageMessage, {
        id: message.id,
        createdAt: message.createdAt,
        role: message.imageMessage.role,
        bytes: message.imageMessage.bytes,
        format: message.imageMessage.format,
        parentMessageId: message.imageMessage.parentMessageId
      });
    } else if (message.actionExecutionMessage) {
      return plainToInstance(ActionExecutionMessage, {
        id: message.id,
        createdAt: message.createdAt,
        name: message.actionExecutionMessage.name,
        arguments: JSON.parse(message.actionExecutionMessage.arguments),
        parentMessageId: message.actionExecutionMessage.parentMessageId
      });
    } else if (message.resultMessage) {
      return plainToInstance(ResultMessage, {
        id: message.id,
        createdAt: message.createdAt,
        actionExecutionId: message.resultMessage.actionExecutionId,
        actionName: message.resultMessage.actionName,
        result: message.resultMessage.result
      });
    } else if (message.agentStateMessage) {
      return plainToInstance(AgentStateMessage, {
        id: message.id,
        threadId: message.agentStateMessage.threadId,
        createdAt: message.createdAt,
        agentName: message.agentStateMessage.agentName,
        nodeName: message.agentStateMessage.nodeName,
        runId: message.agentStateMessage.runId,
        active: message.agentStateMessage.active,
        role: message.agentStateMessage.role,
        state: JSON.parse(message.agentStateMessage.state),
        running: message.agentStateMessage.running
      });
    } else {
      return null;
    }
  });
  return messages.filter((m) => m);
}
__name(convertGqlInputToMessages, "convertGqlInputToMessages");

// src/lib/runtime/copilot-runtime.ts
import { from } from "rxjs";

// src/lib/runtime/retry-utils.ts
var RETRY_CONFIG = {
  maxRetries: 3,
  baseDelayMs: 1e3,
  maxDelayMs: 5e3,
  // HTTP status codes that should be retried
  retryableStatusCodes: [
    502,
    503,
    504,
    408,
    429
  ],
  // Network error patterns that should be retried
  retryableErrorMessages: [
    "fetch failed",
    "network error",
    "connection timeout",
    "ECONNREFUSED",
    "ETIMEDOUT",
    "ENOTFOUND",
    "ECONNRESET"
  ]
};
function isRetryableError(error, response) {
  var _a, _b;
  if (response && RETRY_CONFIG.retryableStatusCodes.includes(response.status)) {
    return true;
  }
  const errorCode = ((_a = error == null ? void 0 : error.cause) == null ? void 0 : _a.code) || (error == null ? void 0 : error.code);
  if (errorCode && RETRY_CONFIG.retryableErrorMessages.includes(errorCode)) {
    return true;
  }
  const errorMessage = ((_b = error == null ? void 0 : error.message) == null ? void 0 : _b.toLowerCase()) || "";
  return RETRY_CONFIG.retryableErrorMessages.some((msg) => errorMessage.includes(msg));
}
__name(isRetryableError, "isRetryableError");
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
__name(sleep, "sleep");
function calculateDelay(attempt) {
  const delay = RETRY_CONFIG.baseDelayMs * Math.pow(2, attempt);
  return Math.min(delay, RETRY_CONFIG.maxDelayMs);
}
__name(calculateDelay, "calculateDelay");
async function fetchWithRetry(url, options, logger2) {
  let lastError;
  for (let attempt = 0; attempt <= RETRY_CONFIG.maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      if (isRetryableError(null, response) && attempt < RETRY_CONFIG.maxRetries) {
        const delay = calculateDelay(attempt);
        logger2 == null ? void 0 : logger2.warn(`Request to ${url} failed with status ${response.status}. Retrying attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries + 1} in ${delay}ms.`);
        await sleep(delay);
        continue;
      }
      return response;
    } catch (error) {
      lastError = error;
      if (isRetryableError(error) && attempt < RETRY_CONFIG.maxRetries) {
        const delay = calculateDelay(attempt);
        logger2 == null ? void 0 : logger2.warn(`Request to ${url} failed with network error. Retrying attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries + 1} in ${delay}ms. Error: ${(error == null ? void 0 : error.message) || String(error)}`);
        await sleep(delay);
        continue;
      }
      break;
    }
  }
  throw lastError;
}
__name(fetchWithRetry, "fetchWithRetry");

// src/lib/runtime/copilot-runtime.ts
import { Client as LangGraphClient2 } from "@langchain/langgraph-sdk";

// src/lib/runtime/remote-lg-action.ts
import { Client as LangGraphClient } from "@langchain/langgraph-sdk";
import { createHash } from "crypto";
import { isValidUUID, randomUUID } from "@copilotkit/shared";
import { parse as parsePartialJson } from "partial-json";

// src/agents/langgraph/events.ts
var LangGraphEventTypes;
(function(LangGraphEventTypes2) {
  LangGraphEventTypes2["OnChainStart"] = "on_chain_start";
  LangGraphEventTypes2["OnChainStream"] = "on_chain_stream";
  LangGraphEventTypes2["OnChainEnd"] = "on_chain_end";
  LangGraphEventTypes2["OnChatModelStart"] = "on_chat_model_start";
  LangGraphEventTypes2["OnChatModelStream"] = "on_chat_model_stream";
  LangGraphEventTypes2["OnChatModelEnd"] = "on_chat_model_end";
  LangGraphEventTypes2["OnToolStart"] = "on_tool_start";
  LangGraphEventTypes2["OnToolEnd"] = "on_tool_end";
  LangGraphEventTypes2["OnCopilotKitStateSync"] = "on_copilotkit_state_sync";
  LangGraphEventTypes2["OnCopilotKitEmitMessage"] = "on_copilotkit_emit_message";
  LangGraphEventTypes2["OnCopilotKitEmitToolCall"] = "on_copilotkit_emit_tool_call";
  LangGraphEventTypes2["OnCustomEvent"] = "on_custom_event";
  LangGraphEventTypes2["OnInterrupt"] = "on_interrupt";
  LangGraphEventTypes2["OnCopilotKitInterrupt"] = "on_copilotkit_interrupt";
  LangGraphEventTypes2["OnCopilotKitError"] = "on_copilotkit_error";
})(LangGraphEventTypes || (LangGraphEventTypes = {}));
var MetaEventNames;
(function(MetaEventNames2) {
  MetaEventNames2["LangGraphInterruptEvent"] = "LangGraphInterruptEvent";
  MetaEventNames2["CopilotKitLangGraphInterruptEvent"] = "CopilotKitLangGraphInterruptEvent";
})(MetaEventNames || (MetaEventNames = {}));
var CustomEventNames;
(function(CustomEventNames2) {
  CustomEventNames2["CopilotKitManuallyEmitMessage"] = "copilotkit_manually_emit_message";
  CustomEventNames2["CopilotKitManuallyEmitToolCall"] = "copilotkit_manually_emit_tool_call";
  CustomEventNames2["CopilotKitManuallyEmitIntermediateState"] = "copilotkit_manually_emit_intermediate_state";
  CustomEventNames2["CopilotKitExit"] = "copilotkit_exit";
})(CustomEventNames || (CustomEventNames = {}));

// src/lib/runtime/remote-lg-action.ts
import { parseJson, CopilotKitMisuseError, CopilotKitLowLevelError as CopilotKitLowLevelError2, CopilotKitError as CopilotKitError2 } from "@copilotkit/shared";
import { RemoveMessage } from "@langchain/core/messages";

// src/lib/streaming.ts
import { CopilotKitLowLevelError, CopilotKitError, CopilotKitErrorCode, ensureStructuredError } from "@copilotkit/shared";

// src/lib/error-messages.ts
var errorConfig = {
  errorPatterns: {
    ECONNREFUSED: {
      message: "Connection refused - the agent service is not running or not accessible at the specified address. Please check that your agent is started and listening on the correct port.",
      category: "network",
      severity: "error",
      actionable: true
    },
    ENOTFOUND: {
      message: "Host not found - the agent service URL appears to be incorrect or the service is not accessible. Please verify the agent endpoint URL.",
      category: "network",
      severity: "error",
      actionable: true
    },
    ETIMEDOUT: {
      message: "Connection timeout - the agent service is taking too long to respond. This could indicate network issues or an overloaded agent service.",
      category: "network",
      severity: "warning",
      actionable: true
    },
    terminated: {
      message: "Agent {context} was unexpectedly terminated. This often indicates an error in the agent service (e.g., authentication failures, missing environment variables, or agent crashes). Check the agent logs for the root cause.",
      category: "connection",
      severity: "error",
      actionable: true
    },
    UND_ERR_SOCKET: {
      message: "Socket connection was closed unexpectedly. This typically indicates the agent service encountered an error and shut down the connection. Check the agent logs for the underlying cause.",
      category: "connection",
      severity: "error",
      actionable: true
    },
    other_side_closed: {
      message: "The agent service closed the connection unexpectedly. This usually indicates an error in the agent service. Check the agent logs for more details.",
      category: "connection",
      severity: "error",
      actionable: true
    },
    fetch_failed: {
      message: "Failed to connect to the agent service. Please verify the agent is running and the endpoint URL is correct.",
      category: "network",
      severity: "error",
      actionable: true
    },
    // Authentication patterns
    "401": {
      message: "Authentication failed. Please check your API keys and ensure they are correctly configured.",
      category: "authentication",
      severity: "error",
      actionable: true
    },
    "api key": {
      message: "API key error detected. Please verify your API key is correct and has the necessary permissions.",
      category: "authentication",
      severity: "error",
      actionable: true
    },
    unauthorized: {
      message: "Unauthorized access. Please check your authentication credentials.",
      category: "authentication",
      severity: "error",
      actionable: true
    },
    // Python-specific error patterns
    AuthenticationError: {
      message: "OpenAI authentication failed. Please check your OPENAI_API_KEY environment variable or API key configuration.",
      category: "authentication",
      severity: "error",
      actionable: true
    },
    "Incorrect API key provided": {
      message: "OpenAI API key is invalid. Please verify your OPENAI_API_KEY is correct and active.",
      category: "authentication",
      severity: "error",
      actionable: true
    },
    RateLimitError: {
      message: "OpenAI rate limit exceeded. Please wait a moment and try again, or check your OpenAI usage limits.",
      category: "network",
      severity: "warning",
      actionable: true
    },
    InvalidRequestError: {
      message: "Invalid request to OpenAI API. Please check your request parameters and model configuration.",
      category: "validation",
      severity: "error",
      actionable: true
    },
    PermissionDeniedError: {
      message: "Permission denied for OpenAI API. Please check your API key permissions and billing status.",
      category: "authentication",
      severity: "error",
      actionable: true
    },
    NotFoundError: {
      message: "OpenAI resource not found. Please check your model name and availability.",
      category: "validation",
      severity: "error",
      actionable: true
    }
  },
  fallbacks: {
    network: "A network error occurred while connecting to the agent service. Please check your connection and ensure the agent service is running.",
    connection: "The connection to the agent service was lost unexpectedly. This may indicate an issue with the agent service.",
    authentication: "Authentication failed. Please check your API keys and credentials.",
    validation: "Invalid input or configuration. Please check your parameters and try again.",
    unknown: "An unexpected error occurred. Please check the logs for more details.",
    default: "An unexpected error occurred. Please check the logs for more details."
  },
  contextTemplates: {
    connection: "connection",
    event_streaming_connection: "event streaming connection",
    agent_streaming_connection: "agent streaming connection",
    langgraph_agent_connection: "LangGraph agent connection"
  }
};
function getFallbackMessage(category) {
  return errorConfig.fallbacks[category] || errorConfig.fallbacks.default;
}
__name(getFallbackMessage, "getFallbackMessage");

// src/lib/streaming.ts
async function writeJsonLineResponseToEventStream(response, eventStream$) {
  const reader = response.getReader();
  const decoder = new TextDecoder();
  let buffer = [];
  function flushBuffer() {
    const currentBuffer = buffer.join("");
    if (currentBuffer.trim().length === 0) {
      return;
    }
    const parts = currentBuffer.split("\n");
    if (parts.length === 0) {
      return;
    }
    const lastPartIsComplete = currentBuffer.endsWith("\n");
    buffer = [];
    if (!lastPartIsComplete) {
      buffer.push(parts.pop());
    }
    parts.map((part) => part.trim()).filter((part) => part != "").forEach((part) => {
      eventStream$.next(JSON.parse(part));
    });
  }
  __name(flushBuffer, "flushBuffer");
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (!done) {
        buffer.push(decoder.decode(value, {
          stream: true
        }));
      }
      flushBuffer();
      if (done) {
        break;
      }
    }
  } catch (error) {
    const structuredError = ensureStructuredError(error, convertStreamingErrorToStructured);
    eventStream$.error(structuredError);
    return;
  }
  eventStream$.complete();
}
__name(writeJsonLineResponseToEventStream, "writeJsonLineResponseToEventStream");
function convertStreamingErrorToStructured(error) {
  var _a, _b, _c, _d, _e, _f, _g;
  let helpfulMessage = generateHelpfulErrorMessage(error);
  if (((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes("fetch failed")) || ((_b = error == null ? void 0 : error.message) == null ? void 0 : _b.includes("ECONNREFUSED")) || ((_c = error == null ? void 0 : error.message) == null ? void 0 : _c.includes("ENOTFOUND")) || ((_d = error == null ? void 0 : error.message) == null ? void 0 : _d.includes("ETIMEDOUT")) || ((_e = error == null ? void 0 : error.message) == null ? void 0 : _e.includes("terminated")) || ((_f = error == null ? void 0 : error.cause) == null ? void 0 : _f.code) === "UND_ERR_SOCKET" || ((_g = error == null ? void 0 : error.message) == null ? void 0 : _g.includes("other side closed")) || (error == null ? void 0 : error.code) === "UND_ERR_SOCKET") {
    return new CopilotKitLowLevelError({
      error: error instanceof Error ? error : new Error(String(error)),
      url: "streaming connection",
      message: helpfulMessage
    });
  }
  return new CopilotKitError({
    message: helpfulMessage,
    code: CopilotKitErrorCode.UNKNOWN
  });
}
__name(convertStreamingErrorToStructured, "convertStreamingErrorToStructured");
function generateHelpfulErrorMessage(error, context = "connection") {
  var _a, _b, _c, _d;
  const baseMessage = (error == null ? void 0 : error.message) || String(error);
  const originalErrorType = (error == null ? void 0 : error.originalErrorType) || ((_a = error == null ? void 0 : error.extensions) == null ? void 0 : _a.originalErrorType);
  const statusCode = (error == null ? void 0 : error.statusCode) || ((_b = error == null ? void 0 : error.extensions) == null ? void 0 : _b.statusCode);
  const responseData = (error == null ? void 0 : error.responseData) || ((_c = error == null ? void 0 : error.extensions) == null ? void 0 : _c.responseData);
  if (originalErrorType) {
    const typeConfig = errorConfig.errorPatterns[originalErrorType];
    if (typeConfig) {
      return typeConfig.message.replace("{context}", context);
    }
  }
  for (const [pattern, config] of Object.entries(errorConfig.errorPatterns)) {
    const shouldMatch = (baseMessage == null ? void 0 : baseMessage.includes(pattern)) || ((_d = error == null ? void 0 : error.cause) == null ? void 0 : _d.code) === pattern || (error == null ? void 0 : error.code) === pattern || statusCode === parseInt(pattern) || pattern === "other_side_closed" && (baseMessage == null ? void 0 : baseMessage.includes("other side closed")) || pattern === "fetch_failed" && (baseMessage == null ? void 0 : baseMessage.includes("fetch failed")) || responseData && JSON.stringify(responseData).includes(pattern);
    if (shouldMatch) {
      return config.message.replace("{context}", context);
    }
  }
  if (isNetworkError(error)) {
    return getFallbackMessage("network");
  }
  if (isConnectionError(error)) {
    return getFallbackMessage("connection");
  }
  if (isAuthenticationError(error)) {
    return getFallbackMessage("authentication");
  }
  return getFallbackMessage("default");
}
__name(generateHelpfulErrorMessage, "generateHelpfulErrorMessage");
function isNetworkError(error) {
  const networkPatterns = [
    "ECONNREFUSED",
    "ENOTFOUND",
    "ETIMEDOUT",
    "fetch_failed"
  ];
  return networkPatterns.some((pattern) => {
    var _a, _b;
    return ((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes(pattern)) || ((_b = error == null ? void 0 : error.cause) == null ? void 0 : _b.code) === pattern || (error == null ? void 0 : error.code) === pattern;
  });
}
__name(isNetworkError, "isNetworkError");
function isConnectionError(error) {
  const connectionPatterns = [
    "terminated",
    "UND_ERR_SOCKET",
    "other side closed"
  ];
  return connectionPatterns.some((pattern) => {
    var _a, _b;
    return ((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes(pattern)) || ((_b = error == null ? void 0 : error.cause) == null ? void 0 : _b.code) === pattern || (error == null ? void 0 : error.code) === pattern;
  });
}
__name(isConnectionError, "isConnectionError");
function isAuthenticationError(error) {
  var _a, _b;
  const authPatterns = [
    "401",
    "api key",
    "unauthorized",
    "authentication",
    "AuthenticationError",
    "PermissionDeniedError"
  ];
  const baseMessage = (error == null ? void 0 : error.message) || String(error);
  const originalErrorType = (error == null ? void 0 : error.originalErrorType) || ((_a = error == null ? void 0 : error.extensions) == null ? void 0 : _a.originalErrorType);
  const statusCode = (error == null ? void 0 : error.statusCode) || ((_b = error == null ? void 0 : error.extensions) == null ? void 0 : _b.statusCode);
  return authPatterns.some((pattern) => (baseMessage == null ? void 0 : baseMessage.toLowerCase().includes(pattern.toLowerCase())) || originalErrorType === pattern || statusCode === 401 || (error == null ? void 0 : error.status) === 401 || (error == null ? void 0 : error.statusCode) === 401);
}
__name(isAuthenticationError, "isAuthenticationError");

// src/lib/runtime/remote-lg-action.ts
function isUserConfigurationError(error) {
  var _a, _b;
  return (error instanceof CopilotKitError2 || error instanceof CopilotKitLowLevelError2) && (error.code === "NETWORK_ERROR" || error.code === "AUTHENTICATION_ERROR" || error.statusCode === 401 || error.statusCode === 403 || ((_a = error.message) == null ? void 0 : _a.toLowerCase().includes("authentication")) || ((_b = error.message) == null ? void 0 : _b.toLowerCase().includes("api key")));
}
__name(isUserConfigurationError, "isUserConfigurationError");
async function execute(args) {
  return new ReadableStream({
    async start(controller) {
      let lastError;
      for (let attempt = 0; attempt <= RETRY_CONFIG.maxRetries; attempt++) {
        try {
          await streamEvents(controller, args);
          controller.close();
          return;
        } catch (err) {
          lastError = err;
          if (isRetryableError(err) && attempt < RETRY_CONFIG.maxRetries) {
            const delay = calculateDelay(attempt);
            console.warn(`LangGraph connection attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries + 1} failed. Retrying in ${delay}ms. Error: ${(err == null ? void 0 : err.message) || String(err)}`);
            await sleep(delay);
            continue;
          }
          break;
        }
      }
      const cause = lastError == null ? void 0 : lastError.cause;
      const errorCode = (cause == null ? void 0 : cause.code) || (lastError == null ? void 0 : lastError.code);
      if (errorCode === "ECONNREFUSED") {
        throw new CopilotKitMisuseError({
          message: `
            The LangGraph client could not connect to the graph after ${RETRY_CONFIG.maxRetries + 1} attempts. Please further check previous logs, which includes further details.
            
            See more: https://docs.copilotkit.ai/troubleshooting/common-issues`
        });
      } else {
        if (lastError instanceof CopilotKitError2 || lastError instanceof CopilotKitLowLevelError2 || lastError instanceof Error && lastError.name && lastError.name.includes("CopilotKit")) {
          throw lastError;
        }
        throw new CopilotKitMisuseError({
          message: `
            The LangGraph client threw unhandled error ${lastError}.
            
            See more: https://docs.copilotkit.ai/troubleshooting/common-issues`
        });
      }
    }
  });
}
__name(execute, "execute");
async function streamEvents(controller, args) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const { deploymentUrl, langsmithApiKey, threadId: argsInitialThreadId, agent, nodeName: initialNodeName, state: initialState, config: explicitConfig, messages, actions, logger: logger2, properties, metaEvents } = args;
  let nodeName = initialNodeName;
  let state = initialState;
  const { name, assistantId: initialAssistantId } = agent;
  const propertyHeaders = properties.authorization ? {
    authorization: `Bearer ${properties.authorization}`
  } : null;
  const client = new LangGraphClient({
    apiUrl: deploymentUrl,
    apiKey: langsmithApiKey,
    defaultHeaders: {
      ...propertyHeaders
    }
  });
  let threadId = argsInitialThreadId ?? randomUUID();
  if (argsInitialThreadId && argsInitialThreadId.startsWith("ck-")) {
    threadId = argsInitialThreadId.substring(3);
  }
  if (!isValidUUID(threadId)) {
    console.warn(`Cannot use the threadId ${threadId} with LangGraph Platform. Must be a valid UUID.`);
  }
  let wasInitiatedWithExistingThread = true;
  try {
    await client.threads.get(threadId);
  } catch (error) {
    wasInitiatedWithExistingThread = false;
    await client.threads.create({
      threadId
    });
  }
  let agentState = {
    values: {}
  };
  if (wasInitiatedWithExistingThread) {
    agentState = await client.threads.getState(threadId);
  }
  const agentStateValues = agentState.values;
  state.messages = agentStateValues.messages;
  const mode = threadId && nodeName != "__end__" && nodeName != void 0 && nodeName != null ? "continue" : "start";
  let formattedMessages = [];
  try {
    formattedMessages = copilotkitMessagesToLangChain(messages);
  } catch (e) {
    logger2.error(e, `Error event thrown: ${e.message}`);
  }
  state = langGraphDefaultMergeState(state, formattedMessages, actions, name);
  const streamInput = mode === "start" ? state : null;
  const payload = {
    input: streamInput,
    streamMode: [
      "events",
      "values",
      "updates"
    ],
    command: void 0
  };
  const lgInterruptMetaEvent = metaEvents == null ? void 0 : metaEvents.find((ev) => ev.name === MetaEventName.LangGraphInterruptEvent);
  if (lgInterruptMetaEvent == null ? void 0 : lgInterruptMetaEvent.response) {
    let response = lgInterruptMetaEvent.response;
    payload.command = {
      resume: parseJson(response, response)
    };
  }
  const interrupts = ((_b = (_a = agentState.tasks) == null ? void 0 : _a[0]) == null ? void 0 : _b.interrupts) ?? [];
  if (mode === "continue" && !interrupts.length) {
    await client.threads.updateState(threadId, {
      values: state,
      asNode: nodeName
    });
  }
  let streamInfo = {
    hashedLgcKey: langsmithApiKey ? createHash("sha256").update(langsmithApiKey).digest("hex") : null
  };
  const assistants = await client.assistants.search();
  const retrievedAssistant = assistants.find((a) => a.name === name || a.assistant_id === initialAssistantId);
  if (!retrievedAssistant) {
    telemetry_client_default.capture("oss.runtime.agent_execution_stream_errored", {
      ...streamInfo,
      error: `Found no assistants for given information, while ${assistants.length} assistants exists`
    });
    console.error(`
      No agent found for the agent name specified in CopilotKit provider
      Please check your available agents or provide an agent ID in the LangGraph Platform endpoint definition.

      
      These are the available agents: [${assistants.map((a) => `${a.name} (ID: ${a.assistant_id})`).join(", ")}]
      `);
    throw new Error("No agent id found");
  }
  const assistantId = retrievedAssistant.assistant_id;
  const graphInfo = await client.assistants.getGraph(assistantId);
  const graphSchema = await client.assistants.getSchemas(assistantId);
  const schemaKeys = getSchemaKeys(graphSchema);
  if (explicitConfig) {
    let filteredConfigurable = retrievedAssistant.config.configurable;
    if (explicitConfig.configurable) {
      filteredConfigurable = (schemaKeys == null ? void 0 : schemaKeys.config) ? filterObjectBySchemaKeys(explicitConfig == null ? void 0 : explicitConfig.configurable, schemaKeys == null ? void 0 : schemaKeys.config) : explicitConfig == null ? void 0 : explicitConfig.configurable;
    }
    const newConfig = {
      ...retrievedAssistant.config,
      ...explicitConfig,
      configurable: filteredConfigurable
    };
    const isRecursionLimitSetToDefault = retrievedAssistant.config.recursion_limit == null && explicitConfig.recursion_limit === 25;
    const configsAreDifferent = JSON.stringify(newConfig) !== JSON.stringify(retrievedAssistant.config);
    const isOnlyRecursionLimitDifferent = isRecursionLimitSetToDefault && JSON.stringify({
      ...newConfig,
      recursion_limit: null
    }) === JSON.stringify({
      ...retrievedAssistant.config,
      recursion_limit: null
    });
    if (configsAreDifferent && !isOnlyRecursionLimitDifferent) {
      await client.assistants.update(assistantId, {
        config: newConfig
      });
    }
  }
  if (payload.input && (schemaKeys == null ? void 0 : schemaKeys.input)) {
    payload.input = filterObjectBySchemaKeys(payload.input, schemaKeys.input);
  }
  let streamingStateExtractor = new StreamingStateExtractor([]);
  let prevNodeName = null;
  let emitIntermediateStateUntilEnd = null;
  let shouldExit = false;
  let externalRunId = null;
  const emit = /* @__PURE__ */ __name((message) => controller.enqueue(new TextEncoder().encode(message)), "emit");
  if ((interrupts == null ? void 0 : interrupts.length) && !((_c = payload.command) == null ? void 0 : _c.resume)) {
    if (!lgInterruptMetaEvent) {
      payload.command = {
        resume: state.messages
      };
    } else {
      interrupts.forEach((interrupt) => {
        emitInterrupt(interrupt.value, emit);
      });
      return Promise.resolve();
    }
  }
  const streamResponse = client.runs.stream(threadId, assistantId, payload);
  let latestStateValues = {};
  let updatedState = state;
  let manuallyEmittedState = null;
  try {
    telemetry_client_default.capture("oss.runtime.agent_execution_stream_started", {
      hashedLgcKey: streamInfo.hashedLgcKey
    });
    for await (let streamResponseChunk of streamResponse) {
      if (![
        "events",
        "values",
        "error",
        "updates"
      ].includes(streamResponseChunk.event))
        continue;
      if (streamResponseChunk.event === "error") {
        const errorData = streamResponseChunk.data;
        if (errorData && typeof errorData === "object" && "error_details" in errorData) {
          const errorDetails = errorData.error_details;
          const preservedError = new CopilotKitLowLevelError2({
            error: new Error(errorDetails.message),
            url: "langgraph platform agent",
            message: `${errorDetails.type}: ${errorDetails.message}`
          });
          if (errorDetails.status_code) {
            preservedError.statusCode = errorDetails.status_code;
          }
          if (errorDetails.response_data) {
            preservedError.responseData = errorDetails.response_data;
          }
          preservedError.agentName = errorDetails.agent_name;
          preservedError.originalErrorType = errorDetails.type;
          throw preservedError;
        }
        const helpfulMessage = generateHelpfulErrorMessage(new Error(errorData.message), "LangGraph Platform agent");
        throw new CopilotKitLowLevelError2({
          error: new Error(errorData.message),
          url: "langgraph platform agent",
          message: helpfulMessage
        });
      }
      const chunk = streamResponseChunk;
      const interruptEvents = chunk.data.__interrupt__;
      if (interruptEvents == null ? void 0 : interruptEvents.length) {
        const interruptValue = interruptEvents == null ? void 0 : interruptEvents[0].value;
        emitInterrupt(interruptValue, emit);
        continue;
      }
      if (streamResponseChunk.event === "updates")
        continue;
      if (streamResponseChunk.event === "values") {
        latestStateValues = chunk.data;
        continue;
      }
      const chunkData = chunk.data;
      const currentNodeName = chunkData.metadata.langgraph_node;
      const eventType = chunkData.event;
      const runId = chunkData.metadata.run_id;
      externalRunId = runId;
      const metadata = chunkData.metadata;
      if (((_e = (_d = chunkData.data) == null ? void 0 : _d.output) == null ? void 0 : _e.model) != null && ((_g = (_f = chunkData.data) == null ? void 0 : _f.output) == null ? void 0 : _g.model) != "") {
        streamInfo.provider = (_i = (_h = chunkData.data) == null ? void 0 : _h.output) == null ? void 0 : _i.model;
      }
      if (metadata.langgraph_host != null && metadata.langgraph_host != "") {
        streamInfo.langGraphHost = metadata.langgraph_host;
      }
      if (metadata.langgraph_version != null && metadata.langgraph_version != "") {
        streamInfo.langGraphVersion = metadata.langgraph_version;
      }
      shouldExit = shouldExit || eventType === LangGraphEventTypes.OnCustomEvent && chunkData.name === CustomEventNames.CopilotKitExit;
      const emitIntermediateState = metadata["copilotkit:emit-intermediate-state"];
      const manuallyEmitIntermediateState = eventType === LangGraphEventTypes.OnCustomEvent && chunkData.name === CustomEventNames.CopilotKitManuallyEmitIntermediateState;
      const exitingNode = nodeName === currentNodeName && eventType === LangGraphEventTypes.OnChainEnd;
      if (exitingNode) {
        manuallyEmittedState = null;
      }
      if (graphInfo["nodes"].some((node) => node.id === currentNodeName)) {
        nodeName = currentNodeName;
      }
      updatedState = manuallyEmittedState ?? latestStateValues;
      if (!nodeName) {
        continue;
      }
      if (manuallyEmitIntermediateState) {
        manuallyEmittedState = chunkData.data;
        emit(getStateSyncEvent({
          threadId,
          runId,
          agentName: agent.name,
          nodeName,
          state: manuallyEmittedState,
          running: true,
          active: true,
          schemaKeys
        }));
        continue;
      }
      if (emitIntermediateState && emitIntermediateStateUntilEnd == null) {
        emitIntermediateStateUntilEnd = nodeName;
      }
      if (emitIntermediateState && eventType === LangGraphEventTypes.OnChatModelStart) {
        streamingStateExtractor = new StreamingStateExtractor(emitIntermediateState);
      }
      if (emitIntermediateState && eventType === LangGraphEventTypes.OnChatModelStream) {
        streamingStateExtractor.bufferToolCalls(chunkData);
      }
      if (emitIntermediateStateUntilEnd !== null) {
        updatedState = {
          ...updatedState,
          ...streamingStateExtractor.extractState()
        };
      }
      if (!emitIntermediateState && currentNodeName === emitIntermediateStateUntilEnd && eventType === LangGraphEventTypes.OnChainEnd) {
        emitIntermediateStateUntilEnd = null;
      }
      if (JSON.stringify(updatedState) !== JSON.stringify(state) || prevNodeName != nodeName || exitingNode) {
        state = updatedState;
        prevNodeName = nodeName;
        emit(getStateSyncEvent({
          threadId,
          runId,
          agentName: agent.name,
          nodeName,
          state,
          running: true,
          active: !exitingNode,
          schemaKeys
        }));
      }
      emit(JSON.stringify(chunkData) + "\n");
    }
    state = await client.threads.getState(threadId);
    const interrupts2 = (_k = (_j = state.tasks) == null ? void 0 : _j[0]) == null ? void 0 : _k.interrupts;
    nodeName = interrupts2 ? nodeName : Object.keys(state.metadata.writes)[0];
    const isEndNode = state.next.length === 0 && !interrupts2;
    telemetry_client_default.capture("oss.runtime.agent_execution_stream_ended", streamInfo);
    emit(getStateSyncEvent({
      threadId,
      runId: externalRunId,
      agentName: agent.name,
      nodeName: isEndNode ? "__end__" : nodeName,
      state: state.values,
      running: !shouldExit,
      active: false,
      includeMessages: true,
      schemaKeys
    }));
    return Promise.resolve();
  } catch (e) {
    if (isUserConfigurationError(e)) {
      logger2.debug({
        error: e.message,
        code: e.code
      }, "User configuration error");
    } else {
      logger2.error(e);
    }
    telemetry_client_default.capture("oss.runtime.agent_execution_stream_errored", {
      ...streamInfo,
      error: e.message
    });
    if (e instanceof CopilotKitError2 || e instanceof CopilotKitLowLevelError2 || e instanceof Error && e.name && e.name.includes("CopilotKit")) {
      throw e;
    }
    return Promise.resolve();
  }
}
__name(streamEvents, "streamEvents");
function getStateSyncEvent({ threadId, runId, agentName, nodeName, state, running, active, includeMessages = false, schemaKeys }) {
  if (!includeMessages) {
    state = Object.keys(state).reduce((acc, key) => {
      if (key !== "messages") {
        acc[key] = state[key];
      }
      return acc;
    }, {});
  } else {
    state = {
      ...state,
      messages: langchainMessagesToCopilotKit(state.messages || [])
    };
  }
  if (schemaKeys == null ? void 0 : schemaKeys.output) {
    state = filterObjectBySchemaKeys(state, schemaKeys.output);
  }
  return JSON.stringify({
    event: LangGraphEventTypes.OnCopilotKitStateSync,
    thread_id: threadId,
    run_id: runId,
    agent_name: agentName,
    node_name: nodeName,
    active,
    state,
    running,
    role: "assistant"
  }) + "\n";
}
__name(getStateSyncEvent, "getStateSyncEvent");
var StreamingStateExtractor = /* @__PURE__ */ __name(class StreamingStateExtractor2 {
  emitIntermediateState;
  toolCallBuffer;
  currentToolCall;
  previouslyParsableState;
  constructor(emitIntermediateState) {
    this.emitIntermediateState = emitIntermediateState;
    this.toolCallBuffer = {};
    this.currentToolCall = null;
    this.previouslyParsableState = {};
  }
  bufferToolCalls(event) {
    if (event.data.chunk.tool_call_chunks.length > 0) {
      const chunk = event.data.chunk.tool_call_chunks[0];
      if (chunk.name !== null && chunk.name !== void 0) {
        this.currentToolCall = chunk.name;
        this.toolCallBuffer[this.currentToolCall] = chunk.args;
      } else if (this.currentToolCall !== null && this.currentToolCall !== void 0) {
        this.toolCallBuffer[this.currentToolCall] += chunk.args;
      }
    }
  }
  getEmitStateConfig(currentToolName) {
    for (const config of this.emitIntermediateState) {
      const stateKey = config["state_key"];
      const tool = config["tool"];
      const toolArgument = config["tool_argument"];
      if (currentToolName === tool) {
        return [
          toolArgument,
          stateKey
        ];
      }
    }
    return [
      null,
      null
    ];
  }
  extractState() {
    const state = {};
    for (const [key, value] of Object.entries(this.toolCallBuffer)) {
      const [argumentName, stateKey] = this.getEmitStateConfig(key);
      if (stateKey === null) {
        continue;
      }
      let parsedValue;
      try {
        parsedValue = parsePartialJson(value);
      } catch (error) {
        if (key in this.previouslyParsableState) {
          parsedValue = this.previouslyParsableState[key];
        } else {
          continue;
        }
      }
      this.previouslyParsableState[key] = parsedValue;
      if (!argumentName) {
        state[stateKey] = parsedValue;
      } else {
        state[stateKey] = parsedValue[argumentName];
      }
    }
    return state;
  }
}, "StreamingStateExtractor");
function langGraphDefaultMergeState(state, messages, actions, agentName) {
  if (messages.length > 0 && "role" in messages[0] && messages[0].role === "system") {
    messages = messages.slice(1);
  }
  const existingMessages = state.messages || [];
  const existingMessageIds = new Set(existingMessages.map((message) => message.id));
  const messageIds = new Set(messages.map((message) => message.id));
  let removedMessages = [];
  if (messages.length < existingMessages.length) {
    removedMessages = existingMessages.filter((m) => !messageIds.has(m.id)).map((m) => new RemoveMessage({
      id: m.id
    }));
  }
  const newMessages = messages.filter((message) => !existingMessageIds.has(message.id));
  return {
    ...state,
    messages: [
      ...removedMessages,
      ...newMessages
    ],
    copilotkit: {
      actions
    }
  };
}
__name(langGraphDefaultMergeState, "langGraphDefaultMergeState");
function langchainMessagesToCopilotKit(messages) {
  const result = [];
  const tool_call_names = {};
  for (const message of messages) {
    if (message.type === "ai") {
      for (const tool_call of message.tool_calls) {
        tool_call_names[tool_call.id] = tool_call.name;
      }
    }
  }
  for (const message of messages) {
    let content = message.content;
    if (content instanceof Array) {
      content = content[0];
    }
    if (content instanceof Object) {
      content = content.text;
    }
    if (message.type === "human") {
      result.push({
        role: "user",
        content,
        id: message.id
      });
    } else if (message.type === "system") {
      result.push({
        role: "system",
        content,
        id: message.id
      });
    } else if (message.type === "ai") {
      if (message.tool_calls && message.tool_calls.length > 0) {
        for (const tool_call of message.tool_calls) {
          result.push({
            id: tool_call.id,
            name: tool_call.name,
            arguments: tool_call.args,
            parentMessageId: message.id
          });
        }
      } else {
        result.push({
          role: "assistant",
          content,
          id: message.id,
          parentMessageId: message.id
        });
      }
    } else if (message.type === "tool") {
      const actionName = tool_call_names[message.tool_call_id] || message.name || "";
      result.push({
        actionExecutionId: message.tool_call_id,
        actionName,
        result: content,
        id: message.id
      });
    }
  }
  const resultsDict = {};
  for (const msg of result) {
    if (msg.actionExecutionId) {
      resultsDict[msg.actionExecutionId] = msg;
    }
  }
  const reorderedResult = [];
  for (const msg of result) {
    if (!("actionExecutionId" in msg)) {
      reorderedResult.push(msg);
    }
    if ("arguments" in msg) {
      const msgId = msg.id;
      if (msgId in resultsDict) {
        reorderedResult.push(resultsDict[msgId]);
      }
    }
  }
  return reorderedResult;
}
__name(langchainMessagesToCopilotKit, "langchainMessagesToCopilotKit");
function copilotkitMessagesToLangChain(messages) {
  const result = [];
  const processedActionExecutions = /* @__PURE__ */ new Set();
  for (const message of messages) {
    if (message.isTextMessage()) {
      if (message.role === "user") {
        result.push({
          ...message,
          role: MessageRole.user
        });
      } else if (message.role === "system") {
        result.push({
          ...message,
          role: MessageRole.system
        });
      } else if (message.role === "assistant") {
        result.push({
          ...message,
          role: MessageRole.assistant
        });
      }
      continue;
    }
    if (message.isImageMessage()) {
      if (message.role === "user") {
        result.push({
          ...message,
          role: MessageRole.user,
          content: ""
        });
      } else if (message.role === "assistant") {
        result.push({
          ...message,
          role: MessageRole.assistant,
          content: ""
        });
      }
      continue;
    }
    if (message.isActionExecutionMessage()) {
      const messageId = message.parentMessageId ?? message.id;
      if (processedActionExecutions.has(messageId)) {
        continue;
      }
      processedActionExecutions.add(messageId);
      const relatedActionExecutions = messages.filter((m) => m.isActionExecutionMessage() && (m.parentMessageId && m.parentMessageId === messageId || m.id === messageId));
      const tool_calls = relatedActionExecutions.map((m) => ({
        name: m.name,
        args: m.arguments,
        id: m.id
      }));
      result.push({
        id: messageId,
        type: "ActionExecutionMessage",
        content: "",
        tool_calls,
        role: MessageRole.assistant
      });
      continue;
    }
    if (message.isResultMessage()) {
      result.push({
        type: message.type,
        content: message.result,
        id: message.id,
        tool_call_id: message.actionExecutionId,
        name: message.actionName,
        role: MessageRole.tool
      });
      continue;
    }
    throw new Error(`Unknown message type ${message.type}`);
  }
  return result;
}
__name(copilotkitMessagesToLangChain, "copilotkitMessagesToLangChain");
function getSchemaKeys(graphSchema) {
  const CONSTANT_KEYS = [
    "messages",
    "copilotkit"
  ];
  let configSchema = null;
  if (graphSchema.config_schema.properties) {
    configSchema = Object.keys(graphSchema.config_schema.properties);
  }
  if (!graphSchema.input_schema.properties || !graphSchema.output_schema.properties) {
    return configSchema;
  }
  const inputSchema = Object.keys(graphSchema.input_schema.properties);
  const outputSchema = Object.keys(graphSchema.output_schema.properties);
  return {
    input: inputSchema && inputSchema.length ? [
      ...inputSchema,
      ...CONSTANT_KEYS
    ] : null,
    output: outputSchema && outputSchema.length ? [
      ...outputSchema,
      ...CONSTANT_KEYS
    ] : null,
    config: configSchema
  };
}
__name(getSchemaKeys, "getSchemaKeys");
function filterObjectBySchemaKeys(obj, schemaKeys) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => schemaKeys.includes(key)));
}
__name(filterObjectBySchemaKeys, "filterObjectBySchemaKeys");
function emitInterrupt(interruptValue, emit) {
  if (typeof interruptValue != "string" && "__copilotkit_interrupt_value__" in interruptValue) {
    const evValue = interruptValue.__copilotkit_interrupt_value__;
    emit(JSON.stringify({
      event: LangGraphEventTypes.OnCopilotKitInterrupt,
      data: {
        value: typeof evValue === "string" ? evValue : JSON.stringify(evValue),
        messages: langchainMessagesToCopilotKit(interruptValue.__copilotkit_messages__)
      }
    }) + "\n");
  } else {
    emit(JSON.stringify({
      event: LangGraphEventTypes.OnInterrupt,
      value: typeof interruptValue === "string" ? interruptValue : JSON.stringify(interruptValue)
    }) + "\n");
  }
}
__name(emitInterrupt, "emitInterrupt");

// src/lib/runtime/mcp-tools-utils.ts
function extractParametersFromSchema(toolOrSchema) {
  var _a;
  const parameters = [];
  const schema = "schema" in (toolOrSchema || {}) ? toolOrSchema.schema : toolOrSchema;
  const toolParameters = ((_a = schema == null ? void 0 : schema.parameters) == null ? void 0 : _a.jsonSchema) || (schema == null ? void 0 : schema.parameters);
  const properties = toolParameters == null ? void 0 : toolParameters.properties;
  const requiredParams = new Set((toolParameters == null ? void 0 : toolParameters.required) || []);
  if (!properties) {
    return parameters;
  }
  for (const paramName in properties) {
    if (Object.prototype.hasOwnProperty.call(properties, paramName)) {
      const paramDef = properties[paramName];
      let type = paramDef.type || "string";
      let description = paramDef.description || "";
      if (type === "array" && paramDef.items) {
        const itemType = paramDef.items.type || "object";
        if (itemType === "object" && paramDef.items.properties) {
          const itemProperties = Object.keys(paramDef.items.properties).join(", ");
          description = description + (description ? " " : "") + `Array of objects with properties: ${itemProperties}`;
        } else {
          type = `array<${itemType}>`;
        }
      }
      if (paramDef.enum && Array.isArray(paramDef.enum)) {
        const enumValues = paramDef.enum.join(" | ");
        description = description + (description ? " " : "") + `Allowed values: ${enumValues}`;
      }
      if (type === "object" && paramDef.properties) {
        const objectProperties = Object.keys(paramDef.properties).join(", ");
        description = description + (description ? " " : "") + `Object with properties: ${objectProperties}`;
      }
      parameters.push({
        name: paramName,
        type,
        description,
        required: requiredParams.has(paramName)
      });
    }
  }
  return parameters;
}
__name(extractParametersFromSchema, "extractParametersFromSchema");
function convertMCPToolsToActions(mcpTools, mcpEndpoint) {
  const actions = [];
  for (const [toolName, tool] of Object.entries(mcpTools)) {
    const parameters = extractParametersFromSchema(tool);
    const handler = /* @__PURE__ */ __name(async (params) => {
      try {
        const result = await tool.execute(params);
        return typeof result === "string" ? result : JSON.stringify(result);
      } catch (error) {
        console.error(`Error executing MCP tool '${toolName}' from endpoint ${mcpEndpoint}:`, error);
        throw new Error(`Execution failed for MCP tool '${toolName}': ${error instanceof Error ? error.message : String(error)}`);
      }
    }, "handler");
    actions.push({
      name: toolName,
      description: tool.description || `MCP tool: ${toolName} (from ${mcpEndpoint})`,
      parameters,
      handler,
      // Add metadata for easier identification/debugging
      _isMCPTool: true,
      _mcpEndpoint: mcpEndpoint
    });
  }
  return actions;
}
__name(convertMCPToolsToActions, "convertMCPToolsToActions");
function generateMcpToolInstructions(toolsMap) {
  if (!toolsMap || Object.keys(toolsMap).length === 0) {
    return "";
  }
  const toolEntries = Object.entries(toolsMap);
  const toolsDoc = toolEntries.map(([name, tool]) => {
    var _a;
    let paramsDoc = "    No parameters required";
    try {
      if (tool.schema && typeof tool.schema === "object") {
        const schema = tool.schema;
        const toolParameters = ((_a = schema.parameters) == null ? void 0 : _a.jsonSchema) || schema.parameters;
        const properties = (toolParameters == null ? void 0 : toolParameters.properties) || schema.properties;
        const requiredParams = (toolParameters == null ? void 0 : toolParameters.required) || schema.required || [];
        if (properties) {
          const paramsList = Object.entries(properties).map(([paramName, propSchema]) => {
            const propDetails = propSchema;
            const requiredMark = requiredParams.includes(paramName) ? "*" : "";
            let typeInfo = propDetails.type || "any";
            let description = propDetails.description ? ` - ${propDetails.description}` : "";
            if (typeInfo === "array" && propDetails.items) {
              const itemType = propDetails.items.type || "object";
              if (itemType === "object" && propDetails.items.properties) {
                const itemProps = Object.keys(propDetails.items.properties).join(", ");
                typeInfo = `array<object>`;
                description = description + (description ? " " : " - ") + `Array of objects with properties: ${itemProps}`;
              } else {
                typeInfo = `array<${itemType}>`;
              }
            }
            if (propDetails.enum && Array.isArray(propDetails.enum)) {
              const enumValues = propDetails.enum.join(" | ");
              description = description + (description ? " " : " - ") + `Allowed values: ${enumValues}`;
            }
            if (typeInfo === "object" && propDetails.properties) {
              const objectProps = Object.keys(propDetails.properties).join(", ");
              description = description + (description ? " " : " - ") + `Object with properties: ${objectProps}`;
            }
            return `    - ${paramName}${requiredMark} (${typeInfo})${description}`;
          });
          if (paramsList.length > 0) {
            paramsDoc = paramsList.join("\n");
          }
        }
      }
    } catch (e) {
      console.error(`Error parsing schema for tool ${name}:`, e);
    }
    return `- ${name}: ${tool.description || ""}
${paramsDoc}`;
  }).join("\n\n");
  return `You have access to the following external tools provided by Model Context Protocol (MCP) servers:

${toolsDoc}

When using these tools:
1. Only provide valid parameters according to their type requirements
2. Required parameters are marked with *
3. For array parameters, provide data in the correct array format
4. For object parameters, include all required nested properties
5. For enum parameters, use only the allowed values listed
6. Format API calls correctly with the expected parameter structure
7. Always check tool responses to determine your next action`;
}
__name(generateMcpToolInstructions, "generateMcpToolInstructions");

// src/lib/runtime/copilot-runtime.ts
var CopilotRuntime = class {
  actions;
  agents;
  remoteEndpointDefinitions;
  langserve = [];
  onBeforeRequest;
  onAfterRequest;
  delegateAgentProcessingToServiceAdapter;
  observability;
  availableAgents;
  onError;
  hasWarnedAboutError = false;
  // +++ MCP Properties +++
  mcpServersConfig;
  mcpActionCache = /* @__PURE__ */ new Map();
  // --- MCP Properties ---
  // +++ MCP Client Factory +++
  createMCPClientImpl;
  // --- MCP Client Factory ---
  constructor(params) {
    var _a, _b, _c, _d;
    if ((params == null ? void 0 : params.actions) && (params == null ? void 0 : params.remoteEndpoints) && (params == null ? void 0 : params.remoteEndpoints.some((e) => e.type === EndpointType.LangGraphPlatform))) {
      console.warn("Actions set in runtime instance will not be available for the agent");
      console.warn(`LangGraph Platform remote endpoints are deprecated in favor of the "agents" property`);
    }
    this.actions = (params == null ? void 0 : params.actions) || [];
    this.availableAgents = [];
    for (const chain of (params == null ? void 0 : params.langserve) || []) {
      const remoteChain = new RemoteChain(chain);
      this.langserve.push(remoteChain.toAction());
    }
    this.remoteEndpointDefinitions = (params == null ? void 0 : params.remoteEndpoints) ?? (params == null ? void 0 : params.remoteActions) ?? [];
    this.onBeforeRequest = (_a = params == null ? void 0 : params.middleware) == null ? void 0 : _a.onBeforeRequest;
    this.onAfterRequest = (_b = params == null ? void 0 : params.middleware) == null ? void 0 : _b.onAfterRequest;
    this.delegateAgentProcessingToServiceAdapter = (params == null ? void 0 : params.delegateAgentProcessingToServiceAdapter) || false;
    this.observability = params == null ? void 0 : params.observability_c;
    this.agents = (params == null ? void 0 : params.agents) ?? {};
    this.onError = params == null ? void 0 : params.onError;
    this.mcpServersConfig = params == null ? void 0 : params.mcpServers;
    this.createMCPClientImpl = params == null ? void 0 : params.createMCPClient;
    if (this.mcpServersConfig && this.mcpServersConfig.length > 0 && !this.createMCPClientImpl) {
      throw new CopilotKitMisuseError2({
        message: "MCP Integration Error: `mcpServers` were provided, but the `createMCPClient` function was not passed to the CopilotRuntime constructor. Please provide an implementation for `createMCPClient`."
      });
    }
    if ((params == null ? void 0 : params.actions) && (((_c = params == null ? void 0 : params.remoteEndpoints) == null ? void 0 : _c.some((e) => e.type === EndpointType.LangGraphPlatform)) || ((_d = this.mcpServersConfig) == null ? void 0 : _d.length))) {
      console.warn("Local 'actions' defined in CopilotRuntime might not be available to remote agents (LangGraph, MCP). Consider defining actions closer to the agent implementation if needed.");
    }
  }
  // +++ MCP Instruction Injection Method +++
  injectMCPToolInstructions(messages, currentActions) {
    const mcpActionsForRequest = currentActions.filter((action) => action._isMCPTool);
    if (!mcpActionsForRequest || mcpActionsForRequest.length === 0) {
      return messages;
    }
    const uniqueMcpTools = /* @__PURE__ */ new Map();
    mcpActionsForRequest.forEach((action) => {
      uniqueMcpTools.set(action.name, action);
    });
    const toolsMap = {};
    Array.from(uniqueMcpTools.values()).forEach((action) => {
      toolsMap[action.name] = {
        description: action.description || "",
        schema: action.parameters ? {
          parameters: {
            properties: action.parameters.reduce((acc, p) => ({
              ...acc,
              [p.name]: {
                type: p.type,
                description: p.description
              }
            }), {}),
            required: action.parameters.filter((p) => p.required).map((p) => p.name)
          }
        } : {},
        execute: async () => ({})
      };
    });
    const mcpToolInstructions = generateMcpToolInstructions(toolsMap);
    if (!mcpToolInstructions) {
      return messages;
    }
    const instructions = mcpToolInstructions + "\nUse them when appropriate to fulfill the user's request.";
    const systemMessageIndex = messages.findIndex((msg) => {
      var _a;
      return ((_a = msg.textMessage) == null ? void 0 : _a.role) === "system";
    });
    const newMessages = [
      ...messages
    ];
    if (systemMessageIndex !== -1) {
      const existingMsg = newMessages[systemMessageIndex];
      if (existingMsg.textMessage) {
        existingMsg.textMessage.content = (existingMsg.textMessage.content ? existingMsg.textMessage.content + "\n\n" : "") + instructions;
      }
    } else {
      newMessages.unshift({
        id: randomId(),
        createdAt: /* @__PURE__ */ new Date(),
        textMessage: {
          role: MessageRole.system,
          content: instructions
        },
        actionExecutionMessage: void 0,
        resultMessage: void 0,
        agentStateMessage: void 0
      });
    }
    return newMessages;
  }
  async processRuntimeRequest(request) {
    var _a, _b, _c, _d, _e;
    const { serviceAdapter, messages: rawMessages, actions: clientSideActionsInput, threadId, runId, outputMessagesPromise, graphqlContext, forwardedParameters, url, extensions, agentSession, agentStates, publicApiKey } = request;
    const eventSource = new RuntimeEventSource({
      errorHandler: async (error, context) => {
        await this.error("error", context, error, publicApiKey);
      },
      errorContext: {
        threadId,
        runId,
        source: "runtime",
        request: {
          operation: "processRuntimeRequest",
          method: "POST",
          url,
          startTime: Date.now()
        },
        agent: agentSession ? {
          name: agentSession.agentName
        } : void 0,
        technical: {
          environment: process.env.NODE_ENV
        }
      }
    });
    const requestStartTime = Date.now();
    const streamedChunks = [];
    try {
      if (Object.keys(this.agents).length && (agentSession == null ? void 0 : agentSession.agentName) && !this.delegateAgentProcessingToServiceAdapter) {
        this.agents = {
          [agentSession.agentName]: this.agents[agentSession.agentName]
        };
      }
      if (agentSession && !this.delegateAgentProcessingToServiceAdapter) {
        return await this.processAgentRequest(request);
      }
      if (serviceAdapter instanceof EmptyAdapter) {
        throw new CopilotKitMisuseError2({
          message: `Invalid adapter configuration: EmptyAdapter is only meant to be used with agent lock mode. 
For non-agent components like useCopilotChatSuggestions, CopilotTextarea, or CopilotTask, 
please use an LLM adapter instead.`
        });
      }
      const serverSideActions = await this.getServerSideActions(request);
      const filteredRawMessages = rawMessages.filter((message) => !message.agentStateMessage);
      const messagesWithInjectedInstructions = this.injectMCPToolInstructions(filteredRawMessages, serverSideActions);
      const inputMessages = convertGqlInputToMessages(messagesWithInjectedInstructions);
      if (((_a = this.observability) == null ? void 0 : _a.enabled) && publicApiKey) {
        try {
          const requestData = {
            threadId,
            runId,
            model: forwardedParameters == null ? void 0 : forwardedParameters.model,
            messages: inputMessages,
            actions: clientSideActionsInput,
            forwardedParameters,
            timestamp: requestStartTime,
            provider: this.detectProvider(serviceAdapter)
          };
          await this.observability.hooks.handleRequest(requestData);
        } catch (error) {
          console.error("Error logging LLM request:", error);
        }
      }
      const serverSideActionsInput = serverSideActions.map((action) => ({
        name: action.name,
        description: action.description,
        jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters))
      }));
      const actionInputs = flattenToolCallsNoDuplicates([
        ...serverSideActionsInput,
        ...clientSideActionsInput.filter(
          // Filter remote actions from CopilotKit core loop
          (action) => action.available !== ActionInputAvailability.remote
        )
      ]);
      await ((_b = this.onBeforeRequest) == null ? void 0 : _b.call(this, {
        threadId,
        runId,
        inputMessages,
        properties: graphqlContext.properties,
        url
      }));
      const result = await serviceAdapter.process({
        messages: inputMessages,
        actions: actionInputs,
        threadId,
        runId,
        eventSource,
        forwardedParameters,
        extensions,
        agentSession,
        agentStates
      });
      const nonEmptyThreadId = threadId ?? result.threadId;
      outputMessagesPromise.then((outputMessages) => {
        var _a2;
        (_a2 = this.onAfterRequest) == null ? void 0 : _a2.call(this, {
          threadId: nonEmptyThreadId,
          runId: result.runId,
          inputMessages,
          outputMessages,
          properties: graphqlContext.properties,
          url
        });
      }).catch((_error) => {
      });
      if (((_c = this.observability) == null ? void 0 : _c.enabled) && publicApiKey) {
        try {
          outputMessagesPromise.then((outputMessages) => {
            const responseData = {
              threadId: result.threadId,
              runId: result.runId,
              model: forwardedParameters == null ? void 0 : forwardedParameters.model,
              // Use collected chunks for progressive mode or outputMessages for regular mode
              output: this.observability.progressive ? streamedChunks : outputMessages,
              latency: Date.now() - requestStartTime,
              timestamp: Date.now(),
              provider: this.detectProvider(serviceAdapter),
              // Indicate this is the final response
              isFinalResponse: true
            };
            try {
              this.observability.hooks.handleResponse(responseData);
            } catch (logError) {
              console.error("Error logging LLM response:", logError);
            }
          }).catch((error) => {
            console.error("Failed to get output messages for logging:", error);
          });
        } catch (error) {
          console.error("Error setting up logging for LLM response:", error);
        }
      }
      if (((_d = this.observability) == null ? void 0 : _d.enabled) && this.observability.progressive && publicApiKey) {
        const originalStream = eventSource.stream.bind(eventSource);
        eventSource.stream = async (callback) => {
          await originalStream(async (eventStream$) => {
            eventStream$.subscribe({
              next: (event) => {
                if (event.type === RuntimeEventTypes.TextMessageContent) {
                  streamedChunks.push(event.content);
                  try {
                    const progressiveData = {
                      threadId: threadId || "",
                      runId,
                      model: forwardedParameters == null ? void 0 : forwardedParameters.model,
                      output: event.content,
                      latency: Date.now() - requestStartTime,
                      timestamp: Date.now(),
                      provider: this.detectProvider(serviceAdapter),
                      isProgressiveChunk: true
                    };
                    Promise.resolve().then(() => {
                      this.observability.hooks.handleResponse(progressiveData);
                    }).catch((error) => {
                      console.error("Error in progressive logging:", error);
                    });
                  } catch (error) {
                    console.error("Error preparing progressive log data:", error);
                  }
                }
              }
            });
            await callback(eventStream$);
          });
        };
      }
      return {
        threadId: nonEmptyThreadId,
        runId: result.runId,
        eventSource,
        serverSideActions,
        actionInputsWithoutAgents: actionInputs.filter((action) => (
          // TODO-AGENTS: do not exclude ALL server side actions
          !serverSideActions.find((serverSideAction) => serverSideAction.name == action.name)
        )),
        extensions: result.extensions
      };
    } catch (error) {
      if (((_e = this.observability) == null ? void 0 : _e.enabled) && publicApiKey) {
        try {
          const errorData = {
            threadId,
            runId,
            model: forwardedParameters == null ? void 0 : forwardedParameters.model,
            error: error instanceof Error ? error : String(error),
            timestamp: Date.now(),
            latency: Date.now() - requestStartTime,
            provider: this.detectProvider(serviceAdapter)
          };
          await this.observability.hooks.handleError(errorData);
        } catch (logError) {
          console.error("Error logging LLM error:", logError);
        }
      }
      let structuredError;
      if (error instanceof CopilotKitError3) {
        structuredError = error;
      } else {
        structuredError = ensureStructuredError2(error, (err) => this.convertStreamingErrorToStructured(err));
      }
      await this.error("error", {
        threadId,
        runId,
        source: "runtime",
        request: {
          operation: "processRuntimeRequest",
          method: "POST",
          url,
          startTime: requestStartTime
        },
        response: {
          endTime: Date.now(),
          latency: Date.now() - requestStartTime
        },
        agent: agentSession ? {
          name: agentSession.agentName
        } : void 0,
        technical: {
          environment: process.env.NODE_ENV,
          stackTrace: error instanceof Error ? error.stack : void 0
        }
      }, structuredError, publicApiKey);
      throw structuredError;
    }
  }
  async getAllAgents(graphqlContext) {
    const agentsWithEndpoints = await this.discoverAgentsFromEndpoints(graphqlContext);
    const aguiAgents = this.discoverAgentsFromAgui();
    this.availableAgents = [
      ...agentsWithEndpoints,
      ...aguiAgents
    ].map((a) => ({
      name: a.name,
      id: a.id
    }));
    return [
      ...agentsWithEndpoints,
      ...aguiAgents
    ];
  }
  async discoverAgentsFromEndpoints(graphqlContext) {
    const agents = this.remoteEndpointDefinitions.reduce(async (acc, endpoint) => {
      const agents2 = await acc;
      if (endpoint.type === EndpointType.LangGraphPlatform) {
        const propertyHeaders = graphqlContext.properties.authorization ? {
          authorization: `Bearer ${graphqlContext.properties.authorization}`
        } : null;
        const client = new LangGraphClient2({
          apiUrl: endpoint.deploymentUrl,
          apiKey: endpoint.langsmithApiKey,
          defaultHeaders: {
            ...propertyHeaders
          }
        });
        let data = [];
        try {
          data = await client.assistants.search();
          if (data && "detail" in data && data.detail.toLowerCase() === "not found") {
            throw new CopilotKitAgentDiscoveryError({
              availableAgents: this.availableAgents
            });
          }
        } catch (e) {
          throw new CopilotKitMisuseError2({
            message: `
              Failed to find or contact remote endpoint at url ${endpoint.deploymentUrl}.
              Make sure the API is running and that it's indeed a LangGraph platform url.
              
              See more: https://docs.copilotkit.ai/troubleshooting/common-issues`
          });
        }
        const endpointAgents = data.map((entry) => ({
          name: entry.graph_id,
          id: entry.assistant_id,
          description: "",
          endpoint
        }));
        return [
          ...agents2,
          ...endpointAgents
        ];
      }
      const cpkEndpoint = endpoint;
      const fetchUrl = `${endpoint.url}/info`;
      try {
        const response = await fetchWithRetry(fetchUrl, {
          method: "POST",
          headers: createHeaders(cpkEndpoint.onBeforeRequest, graphqlContext),
          body: JSON.stringify({
            properties: graphqlContext.properties
          })
        });
        if (!response.ok) {
          if (response.status === 404) {
            throw new CopilotKitApiDiscoveryError({
              url: fetchUrl
            });
          }
          throw new ResolvedCopilotKitError({
            status: response.status,
            url: fetchUrl,
            isRemoteEndpoint: true
          });
        }
        const data = await response.json();
        const endpointAgents = ((data == null ? void 0 : data.agents) ?? []).map((agent) => ({
          name: agent.name,
          description: agent.description ?? "" ?? "",
          id: randomId(),
          endpoint
        }));
        return [
          ...agents2,
          ...endpointAgents
        ];
      } catch (error) {
        if (error instanceof CopilotKitError3) {
          throw error;
        }
        throw new CopilotKitLowLevelError3({
          error,
          url: fetchUrl
        });
      }
    }, Promise.resolve([]));
    return agents;
  }
  discoverAgentsFromAgui() {
    return Object.entries(this.agents ?? []).map(([key, agent]) => ({
      name: agent.agentName ?? key,
      id: agent.agentId ?? key,
      description: agent.description ?? ""
    }));
  }
  async loadAgentState(graphqlContext, threadId, agentName) {
    var _a;
    const agents = await this.getAllAgents(graphqlContext);
    const agent = agents.find((agent2) => agent2.name === agentName);
    if (!agent) {
      throw new Error("Agent not found");
    }
    if ("endpoint" in agent && (agent.endpoint.type === EndpointType.CopilotKit || !("type" in agent.endpoint))) {
      const cpkEndpoint = agent.endpoint;
      const fetchUrl = `${cpkEndpoint.url}/agents/state`;
      try {
        const response = await fetchWithRetry(fetchUrl, {
          method: "POST",
          headers: createHeaders(cpkEndpoint.onBeforeRequest, graphqlContext),
          body: JSON.stringify({
            properties: graphqlContext.properties,
            threadId,
            name: agentName
          })
        });
        if (!response.ok) {
          if (response.status === 404) {
            throw new CopilotKitApiDiscoveryError({
              url: fetchUrl
            });
          }
          let errorMessage = `HTTP ${response.status} error`;
          try {
            const errorBody = await response.text();
            const parsedError = JSON.parse(errorBody);
            if (parsedError.error && typeof parsedError.error === "string") {
              errorMessage = parsedError.error;
            }
          } catch {
          }
          throw new ResolvedCopilotKitError({
            status: response.status,
            url: fetchUrl,
            isRemoteEndpoint: true,
            message: errorMessage
          });
        }
        const data = await response.json();
        return {
          ...data,
          state: JSON.stringify(data.state),
          messages: JSON.stringify(data.messages)
        };
      } catch (error) {
        if (error instanceof CopilotKitError3) {
          throw error;
        }
        throw new CopilotKitLowLevelError3({
          error,
          url: fetchUrl
        });
      }
    }
    const propertyHeaders = graphqlContext.properties.authorization ? {
      authorization: `Bearer ${graphqlContext.properties.authorization}`
    } : null;
    let state = {};
    try {
      let client;
      if ("endpoint" in agent && agent.endpoint.type === EndpointType.LangGraphPlatform) {
        client = new LangGraphClient2({
          apiUrl: agent.endpoint.deploymentUrl,
          apiKey: agent.endpoint.langsmithApiKey,
          defaultHeaders: {
            ...propertyHeaders
          }
        });
      } else {
        const aguiAgent = graphqlContext._copilotkit.runtime.agents[agent.name];
        if (!aguiAgent) {
          throw new Error(`Agent: ${agent.name} could not be resolved`);
        }
        client = aguiAgent.client ?? null;
      }
      state = client ? (await client.threads.getState(threadId)).values : {};
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorStatus = ((_a = error == null ? void 0 : error.response) == null ? void 0 : _a.status) || (error == null ? void 0 : error.status);
      if (errorStatus === 404) {
        state = {};
      } else {
        console.debug(`Agent '${agentName}' configuration issue: ${errorMessage}`);
        throw new ResolvedCopilotKitError({
          status: 400,
          message: `Agent '${agentName}' failed to execute: ${errorMessage}`,
          code: CopilotKitErrorCode2.CONFIGURATION_ERROR
        });
      }
    }
    if (Object.keys(state).length === 0) {
      return {
        threadId: threadId || "",
        threadExists: false,
        state: JSON.stringify({}),
        messages: JSON.stringify([])
      };
    } else {
      const { messages, ...stateWithoutMessages } = state;
      const copilotkitMessages = langchainMessagesToCopilotKit(messages);
      return {
        threadId: threadId || "",
        threadExists: true,
        state: JSON.stringify(stateWithoutMessages),
        messages: JSON.stringify(copilotkitMessages)
      };
    }
    throw new Error(`Agent: ${agent.name} could not be resolved`);
  }
  async processAgentRequest(request) {
    var _a, _b, _c, _d, _e;
    const { messages: rawMessages, outputMessagesPromise, graphqlContext, agentSession, threadId: threadIdFromRequest, metaEvents, publicApiKey, forwardedParameters } = request;
    const { agentName, nodeName } = agentSession;
    const requestStartTime = Date.now();
    const streamedChunks = [];
    const threadId = threadIdFromRequest ?? agentSession.threadId;
    await this.error("agent_state", {
      threadId,
      source: "agent",
      request: {
        operation: "processAgentRequest",
        method: "POST",
        startTime: requestStartTime
      },
      agent: {
        name: agentName,
        nodeName
      },
      messages: {
        input: rawMessages,
        messageCount: rawMessages.length
      },
      technical: {
        environment: process.env.NODE_ENV
      }
    }, void 0, publicApiKey);
    const serverSideActions = await this.getServerSideActions(request);
    const messages = convertGqlInputToMessages(rawMessages);
    const currentAgent = serverSideActions.find((action) => action.name === agentName && isRemoteAgentAction(action));
    if (!currentAgent) {
      throw new CopilotKitAgentDiscoveryError({
        agentName,
        availableAgents: this.availableAgents
      });
    }
    const availableActionsForCurrentAgent = serverSideActions.filter((action) => (
      // Case 1: Keep all regular (non-agent) actions
      !isRemoteAgentAction(action) || // Case 2: For agent actions, keep all except self (prevent infinite loops)
      isRemoteAgentAction(action) && action.name !== agentName
    )).map((action) => ({
      name: action.name,
      description: action.description,
      jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters))
    }));
    const allAvailableActions = flattenToolCallsNoDuplicates([
      ...availableActionsForCurrentAgent,
      ...request.actions
    ]);
    if (((_a = this.observability) == null ? void 0 : _a.enabled) && publicApiKey) {
      try {
        const requestData = {
          threadId,
          runId: void 0,
          model: forwardedParameters == null ? void 0 : forwardedParameters.model,
          messages,
          actions: allAvailableActions,
          forwardedParameters,
          timestamp: requestStartTime,
          provider: "agent",
          agentName,
          nodeName
        };
        await this.observability.hooks.handleRequest(requestData);
      } catch (error) {
        console.error("Error logging agent request:", error);
      }
    }
    await ((_b = this.onBeforeRequest) == null ? void 0 : _b.call(this, {
      threadId,
      runId: void 0,
      inputMessages: messages,
      properties: graphqlContext.properties
    }));
    try {
      const eventSource = new RuntimeEventSource({
        errorHandler: async (error, context) => {
          await this.error("error", context, error, publicApiKey);
        },
        errorContext: {
          threadId,
          source: "agent",
          request: {
            operation: "processAgentRequest",
            method: "POST",
            startTime: requestStartTime
          },
          agent: {
            name: agentName,
            nodeName
          },
          technical: {
            environment: process.env.NODE_ENV
          }
        }
      });
      const stream = await currentAgent.remoteAgentHandler({
        name: agentName,
        threadId,
        nodeName,
        metaEvents,
        actionInputsWithoutAgents: allAvailableActions
      });
      if (((_c = this.observability) == null ? void 0 : _c.enabled) && this.observability.progressive && publicApiKey) {
        const originalStream = eventSource.stream.bind(eventSource);
        eventSource.stream = async (callback) => {
          await originalStream(async (eventStream$) => {
            eventStream$.subscribe({
              next: (event) => {
                if (event.type === RuntimeEventTypes.TextMessageContent) {
                  streamedChunks.push(event.content);
                  try {
                    const progressiveData = {
                      threadId: threadId || "",
                      runId: void 0,
                      model: forwardedParameters == null ? void 0 : forwardedParameters.model,
                      output: event.content,
                      latency: Date.now() - requestStartTime,
                      timestamp: Date.now(),
                      provider: "agent",
                      isProgressiveChunk: true,
                      agentName,
                      nodeName
                    };
                    Promise.resolve().then(() => {
                      this.observability.hooks.handleResponse(progressiveData);
                    }).catch((error) => {
                      console.error("Error in progressive agent logging:", error);
                    });
                  } catch (error) {
                    console.error("Error preparing progressive agent log data:", error);
                  }
                }
              }
            });
            await callback(eventStream$);
          });
        };
      }
      eventSource.stream(async (eventStream$) => {
        from(stream).subscribe({
          next: (event) => eventStream$.next(event),
          error: async (err) => {
            var _a2;
            if (((_a2 = this.observability) == null ? void 0 : _a2.enabled) && publicApiKey) {
              try {
                const errorData = {
                  threadId,
                  runId: void 0,
                  model: forwardedParameters == null ? void 0 : forwardedParameters.model,
                  error: err instanceof Error ? err : String(err),
                  timestamp: Date.now(),
                  latency: Date.now() - requestStartTime,
                  provider: "agent",
                  agentName,
                  nodeName
                };
                this.observability.hooks.handleError(errorData);
              } catch (logError) {
                console.error("Error logging agent error:", logError);
              }
            }
            const structuredError = ensureStructuredError2(err, (error) => this.convertStreamingErrorToStructured(error));
            await this.error("error", {
              threadId,
              source: "agent",
              request: {
                operation: "processAgentRequest",
                method: "POST",
                startTime: requestStartTime
              },
              response: {
                endTime: Date.now(),
                latency: Date.now() - requestStartTime
              },
              agent: {
                name: agentName,
                nodeName
              },
              technical: {
                environment: process.env.NODE_ENV,
                stackTrace: err instanceof Error ? err.stack : void 0
              }
            }, structuredError, publicApiKey);
            eventStream$.error(structuredError);
            eventStream$.complete();
          },
          complete: () => eventStream$.complete()
        });
      });
      if (((_d = this.observability) == null ? void 0 : _d.enabled) && publicApiKey) {
        outputMessagesPromise.then((outputMessages) => {
          const responseData = {
            threadId,
            runId: void 0,
            model: forwardedParameters == null ? void 0 : forwardedParameters.model,
            // Use collected chunks for progressive mode or outputMessages for regular mode
            output: this.observability.progressive ? streamedChunks : outputMessages,
            latency: Date.now() - requestStartTime,
            timestamp: Date.now(),
            provider: "agent",
            isFinalResponse: true,
            agentName,
            nodeName
          };
          try {
            this.observability.hooks.handleResponse(responseData);
          } catch (logError) {
            console.error("Error logging agent response:", logError);
          }
        }).catch((error) => {
          console.error("Failed to get output messages for agent logging:", error);
        });
      }
      outputMessagesPromise.then((outputMessages) => {
        var _a2;
        (_a2 = this.onAfterRequest) == null ? void 0 : _a2.call(this, {
          threadId,
          runId: void 0,
          inputMessages: messages,
          outputMessages,
          properties: graphqlContext.properties
        });
      }).catch((_error) => {
      });
      return {
        threadId,
        runId: void 0,
        eventSource,
        serverSideActions,
        actionInputsWithoutAgents: allAvailableActions
      };
    } catch (error) {
      if (((_e = this.observability) == null ? void 0 : _e.enabled) && publicApiKey) {
        try {
          const errorData = {
            threadId,
            runId: void 0,
            model: forwardedParameters == null ? void 0 : forwardedParameters.model,
            error: error instanceof Error ? error : String(error),
            timestamp: Date.now(),
            latency: Date.now() - requestStartTime,
            provider: "agent",
            agentName,
            nodeName
          };
          await this.observability.hooks.handleError(errorData);
        } catch (logError) {
          console.error("Error logging agent error:", logError);
        }
      }
      const structuredError = ensureStructuredError2(error, (err) => this.convertStreamingErrorToStructured(err));
      await this.error("error", {
        threadId,
        source: "agent",
        request: {
          operation: "processAgentRequest",
          method: "POST",
          startTime: requestStartTime
        },
        response: {
          endTime: Date.now(),
          latency: Date.now() - requestStartTime
        },
        agent: {
          name: agentName,
          nodeName
        },
        technical: {
          environment: process.env.NODE_ENV,
          stackTrace: error instanceof Error ? error.stack : void 0
        }
      }, structuredError, publicApiKey);
      console.error("Error getting response:", error);
      throw structuredError;
    }
  }
  async getServerSideActions(request) {
    var _a, _b, _c;
    const { graphqlContext, messages: rawMessages, agentStates, url } = request;
    const inputMessages = convertGqlInputToMessages(rawMessages);
    const langserveFunctions = [];
    for (const chainPromise of this.langserve) {
      try {
        const chain = await chainPromise;
        langserveFunctions.push(chain);
      } catch (error) {
        console.error("Error loading langserve chain:", error);
      }
    }
    const remoteEndpointDefinitions = this.remoteEndpointDefinitions.map((endpoint) => ({
      ...endpoint,
      type: resolveEndpointType(endpoint)
    }));
    const remoteActions = await setupRemoteActions({
      remoteEndpointDefinitions,
      graphqlContext,
      messages: inputMessages,
      agentStates,
      frontendUrl: url,
      agents: this.agents,
      metaEvents: request.metaEvents,
      nodeName: (_a = request.agentSession) == null ? void 0 : _a.nodeName
    });
    const configuredActions = typeof this.actions === "function" ? this.actions({
      properties: graphqlContext.properties,
      url
    }) : this.actions;
    const requestSpecificMCPActions = [];
    if (this.createMCPClientImpl) {
      const baseEndpoints = this.mcpServersConfig || [];
      const requestEndpoints = ((_b = graphqlContext.properties) == null ? void 0 : _b.mcpServers) || ((_c = graphqlContext.properties) == null ? void 0 : _c.mcpEndpoints) || [];
      const effectiveEndpointsMap = /* @__PURE__ */ new Map();
      [
        ...baseEndpoints
      ].forEach((ep) => {
        if (ep && ep.endpoint) {
          effectiveEndpointsMap.set(ep.endpoint, ep);
        }
      });
      [
        ...requestEndpoints
      ].forEach((ep) => {
        if (ep && ep.endpoint) {
          effectiveEndpointsMap.set(ep.endpoint, ep);
        }
      });
      const effectiveEndpoints = Array.from(effectiveEndpointsMap.values());
      for (const config of effectiveEndpoints) {
        const endpointUrl = config.endpoint;
        let actionsForEndpoint = this.mcpActionCache.get(endpointUrl);
        if (!actionsForEndpoint) {
          let client = null;
          try {
            client = await this.createMCPClientImpl(config);
            const tools = await client.tools();
            actionsForEndpoint = convertMCPToolsToActions(tools, endpointUrl);
            this.mcpActionCache.set(endpointUrl, actionsForEndpoint);
          } catch (error) {
            console.error(`MCP: Failed to fetch tools from endpoint ${endpointUrl}. Skipping. Error:`, error);
            actionsForEndpoint = [];
            this.mcpActionCache.set(endpointUrl, actionsForEndpoint);
          }
        }
        requestSpecificMCPActions.push(...actionsForEndpoint || []);
      }
    }
    return [
      ...configuredActions,
      ...langserveFunctions,
      ...remoteActions,
      ...requestSpecificMCPActions
    ];
  }
  // Add helper method to detect provider
  detectProvider(serviceAdapter) {
    const adapterName = serviceAdapter.constructor.name;
    if (adapterName.includes("OpenAI"))
      return "openai";
    if (adapterName.includes("Anthropic"))
      return "anthropic";
    if (adapterName.includes("Google"))
      return "google";
    if (adapterName.includes("Groq"))
      return "groq";
    if (adapterName.includes("LangChain"))
      return "langchain";
    return void 0;
  }
  convertStreamingErrorToStructured(error) {
    var _a, _b, _c, _d, _e, _f, _g;
    let helpfulMessage = generateHelpfulErrorMessage(error, "agent streaming connection");
    if (((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes("fetch failed")) || ((_b = error == null ? void 0 : error.message) == null ? void 0 : _b.includes("ECONNREFUSED")) || ((_c = error == null ? void 0 : error.message) == null ? void 0 : _c.includes("ENOTFOUND")) || ((_d = error == null ? void 0 : error.message) == null ? void 0 : _d.includes("ETIMEDOUT")) || ((_e = error == null ? void 0 : error.message) == null ? void 0 : _e.includes("terminated")) || ((_f = error == null ? void 0 : error.cause) == null ? void 0 : _f.code) === "UND_ERR_SOCKET" || ((_g = error == null ? void 0 : error.message) == null ? void 0 : _g.includes("other side closed")) || (error == null ? void 0 : error.code) === "UND_ERR_SOCKET") {
      return new CopilotKitLowLevelError3({
        error: error instanceof Error ? error : new Error(String(error)),
        url: "agent streaming connection",
        message: helpfulMessage
      });
    }
    return new CopilotKitError3({
      message: helpfulMessage,
      code: CopilotKitErrorCode2.UNKNOWN
    });
  }
  async error(type, context, error, publicApiKey) {
    if (!this.onError)
      return;
    if (!publicApiKey) {
      if (!this.hasWarnedAboutError) {
        console.warn("CopilotKit: onError handler provided but requires publicApiKey to be defined for error handling to work.");
        this.hasWarnedAboutError = true;
      }
      return;
    }
    try {
      const errorEvent = {
        type,
        timestamp: Date.now(),
        context,
        ...error && {
          error
        }
      };
      await this.onError(errorEvent);
    } catch (errorHandlerError) {
      console.error("Error in onError handler:", errorHandlerError);
    }
  }
  /**
  * Public method to handle GraphQL validation errors
  * This allows the GraphQL resolver to send validation errors through the error system
  */
  async errorGraphQLError(error, context) {
    if (!this.onError)
      return;
    try {
      await this.onError({
        type: "error",
        timestamp: Date.now(),
        context: {
          source: "runtime",
          request: {
            operation: context.operation,
            startTime: Date.now()
          },
          technical: {
            environment: process.env.NODE_ENV
          },
          metadata: {
            errorType: "GraphQLValidationError",
            cloudConfigPresent: context.cloudConfigPresent,
            guardrailsEnabled: context.guardrailsEnabled
          }
        },
        error
      });
    } catch (errorHandlerError) {
      console.error("Error in onError handler:", errorHandlerError);
    }
  }
};
__name(CopilotRuntime, "CopilotRuntime");
function flattenToolCallsNoDuplicates(toolsByPriority) {
  let allTools = [];
  const allToolNames = [];
  for (const tool of toolsByPriority) {
    if (!allToolNames.includes(tool.name)) {
      allTools.push(tool);
      allToolNames.push(tool.name);
    }
  }
  return allTools;
}
__name(flattenToolCallsNoDuplicates, "flattenToolCallsNoDuplicates");
function copilotKitEndpoint(config) {
  return {
    ...config,
    type: EndpointType.CopilotKit
  };
}
__name(copilotKitEndpoint, "copilotKitEndpoint");
function langGraphPlatformEndpoint(config) {
  return {
    ...config,
    type: EndpointType.LangGraphPlatform
  };
}
__name(langGraphPlatformEndpoint, "langGraphPlatformEndpoint");
function resolveEndpointType(endpoint) {
  if (!endpoint.type) {
    if ("deploymentUrl" in endpoint && "agents" in endpoint) {
      return EndpointType.LangGraphPlatform;
    } else {
      return EndpointType.CopilotKit;
    }
  }
  return endpoint.type;
}
__name(resolveEndpointType, "resolveEndpointType");

// src/lib/telemetry-client.ts
var packageJson = require_package();
var telemetryClient = new TelemetryClient({
  packageName: packageJson.name,
  packageVersion: packageJson.version
});
function getRuntimeInstanceTelemetryInfo(options) {
  var _a, _b;
  const runtime = options.runtime;
  const endpointsInfo = runtime.remoteEndpointDefinitions.reduce((acc, endpoint) => {
    let info = {
      ...acc
    };
    const endpointType = resolveEndpointType(endpoint);
    if (!info.endpointTypes.includes(endpointType)) {
      info = {
        ...info,
        endpointTypes: [
          ...info.endpointTypes,
          endpointType
        ]
      };
    }
    if (endpointType === EndpointType.LangGraphPlatform) {
      const ep = endpoint;
      info = {
        ...info,
        agentsAmount: ep.agents.length,
        hashedKey: ep.langsmithApiKey ? createHash2("sha256").update(ep.langsmithApiKey).digest("hex") : null
      };
    }
    return info;
  }, {
    endpointTypes: [],
    agentsAmount: null,
    hashedKey: null
  });
  const publicApiKey = (_a = options.cloud) == null ? void 0 : _a.publicApiKey;
  const apiKeyProvided = !!publicApiKey && publicApiKey.trim().length > 0;
  return {
    actionsAmount: runtime.actions.length,
    endpointsAmount: runtime.remoteEndpointDefinitions.length,
    endpointTypes: endpointsInfo.endpointTypes,
    agentsAmount: endpointsInfo.agentsAmount,
    hashedLgcKey: endpointsInfo.hashedKey,
    "cloud.api_key_provided": apiKeyProvided,
    ...apiKeyProvided ? {
      "cloud.public_api_key": publicApiKey
    } : {},
    ...((_b = options.cloud) == null ? void 0 : _b.baseUrl) ? {
      "cloud.base_url": options.cloud.baseUrl
    } : {}
  };
}
__name(getRuntimeInstanceTelemetryInfo, "getRuntimeInstanceTelemetryInfo");
var telemetry_client_default = telemetryClient;

// src/agents/langgraph/event-source.ts
import { CopilotKitLowLevelError as CopilotKitLowLevelError4, isStructuredCopilotKitError } from "@copilotkit/shared";
import { catchError, mergeMap, ReplaySubject, scan } from "rxjs";
var RemoteLangGraphEventSource = class {
  eventStream$ = new ReplaySubject();
  shouldEmitToolCall(shouldEmitToolCalls, toolCallName) {
    if (typeof shouldEmitToolCalls === "boolean") {
      return shouldEmitToolCalls;
    }
    if (Array.isArray(shouldEmitToolCalls)) {
      return shouldEmitToolCalls.includes(toolCallName);
    }
    return shouldEmitToolCalls === toolCallName;
  }
  getCurrentContent(event) {
    var _a, _b, _c, _d, _e;
    const content = ((_c = (_b = (_a = event.data) == null ? void 0 : _a.chunk) == null ? void 0 : _b.kwargs) == null ? void 0 : _c.content) ?? ((_e = (_d = event.data) == null ? void 0 : _d.chunk) == null ? void 0 : _e.content);
    if (!content) {
      const toolCallChunks = this.getCurrentToolCallChunks(event) ?? [];
      for (const chunk of toolCallChunks) {
        if (chunk.args) {
          return chunk.args;
        }
      }
    }
    if (typeof content === "string") {
      return content;
    } else if (Array.isArray(content) && content.length > 0) {
      return content[0].text;
    }
    return null;
  }
  getCurrentMessageId(event) {
    var _a, _b, _c, _d, _e;
    return ((_c = (_b = (_a = event.data) == null ? void 0 : _a.chunk) == null ? void 0 : _b.kwargs) == null ? void 0 : _c.id) ?? ((_e = (_d = event.data) == null ? void 0 : _d.chunk) == null ? void 0 : _e.id);
  }
  getCurrentToolCallChunks(event) {
    var _a, _b, _c, _d, _e;
    return ((_c = (_b = (_a = event.data) == null ? void 0 : _a.chunk) == null ? void 0 : _b.kwargs) == null ? void 0 : _c.tool_call_chunks) ?? ((_e = (_d = event.data) == null ? void 0 : _d.chunk) == null ? void 0 : _e.tool_call_chunks);
  }
  getResponseMetadata(event) {
    var _a, _b, _c, _d, _e;
    return ((_c = (_b = (_a = event.data) == null ? void 0 : _a.chunk) == null ? void 0 : _b.kwargs) == null ? void 0 : _c.response_metadata) ?? ((_e = (_d = event.data) == null ? void 0 : _d.chunk) == null ? void 0 : _e.response_metadata);
  }
  processLangGraphEvents() {
    let lastEventWithState = null;
    return this.eventStream$.pipe(scan((acc, event) => {
      if (event.event === LangGraphEventTypes.OnChatModelStream) {
        const prevMessageId = acc.lastMessageId;
        acc.currentContent = this.getCurrentContent(event);
        acc.lastMessageId = this.getCurrentMessageId(event) ?? acc.lastMessageId;
        const toolCallChunks = this.getCurrentToolCallChunks(event) ?? [];
        const responseMetadata = this.getResponseMetadata(event);
        const toolCallCheck = toolCallChunks && toolCallChunks.length > 0;
        let isToolCallEnd = (responseMetadata == null ? void 0 : responseMetadata.finish_reason) === "tool_calls";
        acc.isToolCallStart = toolCallChunks.some((chunk) => chunk.name && chunk.id);
        acc.isMessageStart = prevMessageId !== acc.lastMessageId && !acc.isToolCallStart;
        let previousRoundHadToolCall = acc.isToolCall;
        acc.isToolCall = toolCallCheck;
        if (previousRoundHadToolCall && !toolCallCheck) {
          isToolCallEnd = true;
        }
        acc.isToolCallEnd = isToolCallEnd;
        acc.isMessageEnd = (responseMetadata == null ? void 0 : responseMetadata.finish_reason) === "stop";
        ({ name: acc.lastToolCallName, id: acc.lastToolCallId } = toolCallChunks.find((chunk) => chunk.name && chunk.id) ?? {
          name: acc.lastToolCallName,
          id: acc.lastToolCallId
        });
      }
      acc.event = event;
      lastEventWithState = acc;
      return acc;
    }, {
      event: null,
      isMessageStart: false,
      isMessageEnd: false,
      isToolCallStart: false,
      isToolCallEnd: false,
      isToolCall: false,
      lastMessageId: null,
      lastToolCallId: null,
      lastToolCallName: null,
      currentContent: null,
      processedToolCallIds: /* @__PURE__ */ new Set()
    }), mergeMap((acc) => {
      const events = [];
      let shouldEmitMessages = true;
      let shouldEmitToolCalls = true;
      if (acc.event.event == LangGraphEventTypes.OnChatModelStream) {
        if ("copilotkit:emit-tool-calls" in (acc.event.metadata || {})) {
          shouldEmitToolCalls = acc.event.metadata["copilotkit:emit-tool-calls"];
        }
        if ("copilotkit:emit-messages" in (acc.event.metadata || {})) {
          shouldEmitMessages = acc.event.metadata["copilotkit:emit-messages"];
        }
      }
      if (acc.event.event === LangGraphEventTypes.OnInterrupt) {
        events.push({
          type: RuntimeEventTypes.MetaEvent,
          name: RuntimeMetaEventName.LangGraphInterruptEvent,
          value: acc.event.value
        });
      }
      if (acc.event.event === LangGraphEventTypes.OnCopilotKitInterrupt) {
        events.push({
          type: RuntimeEventTypes.MetaEvent,
          name: RuntimeMetaEventName.CopilotKitLangGraphInterruptEvent,
          data: acc.event.data
        });
      }
      if (acc.event.event === LangGraphEventTypes.OnCopilotKitError) {
        const errorData = acc.event.data.error;
        const preservedError = new CopilotKitLowLevelError4({
          error: new Error(errorData.message),
          url: "langgraph agent",
          message: `${errorData.type}: ${errorData.message}`
        });
        if (errorData.status_code) {
          preservedError.statusCode = errorData.status_code;
        }
        if (errorData.response_data) {
          preservedError.responseData = errorData.response_data;
        }
        preservedError.agentName = errorData.agent_name;
        preservedError.originalErrorType = errorData.type;
        throw preservedError;
      }
      const responseMetadata = this.getResponseMetadata(acc.event);
      if (acc.isToolCallEnd && this.shouldEmitToolCall(shouldEmitToolCalls, acc.lastToolCallName) && acc.lastToolCallId && !acc.processedToolCallIds.has(acc.lastToolCallId)) {
        acc.processedToolCallIds.add(acc.lastToolCallId);
        events.push({
          type: RuntimeEventTypes.ActionExecutionEnd,
          actionExecutionId: acc.lastToolCallId
        });
      } else if ((responseMetadata == null ? void 0 : responseMetadata.finish_reason) === "stop" && shouldEmitMessages) {
        events.push({
          type: RuntimeEventTypes.TextMessageEnd,
          messageId: acc.lastMessageId
        });
      }
      switch (acc.event.event) {
        case LangGraphEventTypes.OnCustomEvent:
          if (acc.event.name === CustomEventNames.CopilotKitManuallyEmitMessage) {
            events.push({
              type: RuntimeEventTypes.TextMessageStart,
              messageId: acc.event.data.message_id
            });
            events.push({
              type: RuntimeEventTypes.TextMessageContent,
              messageId: acc.event.data.message_id,
              content: acc.event.data.message
            });
            events.push({
              type: RuntimeEventTypes.TextMessageEnd,
              messageId: acc.event.data.message_id
            });
          } else if (acc.event.name === CustomEventNames.CopilotKitManuallyEmitToolCall) {
            events.push({
              type: RuntimeEventTypes.ActionExecutionStart,
              actionExecutionId: acc.event.data.id,
              actionName: acc.event.data.name,
              parentMessageId: acc.event.data.id
            });
            events.push({
              type: RuntimeEventTypes.ActionExecutionArgs,
              actionExecutionId: acc.event.data.id,
              args: JSON.stringify(acc.event.data.args)
            });
            events.push({
              type: RuntimeEventTypes.ActionExecutionEnd,
              actionExecutionId: acc.event.data.id
            });
          }
          break;
        case LangGraphEventTypes.OnCopilotKitStateSync:
          events.push({
            type: RuntimeEventTypes.AgentStateMessage,
            threadId: acc.event.thread_id,
            role: acc.event.role,
            agentName: acc.event.agent_name,
            nodeName: acc.event.node_name,
            runId: acc.event.run_id,
            active: acc.event.active,
            state: JSON.stringify(acc.event.state),
            running: acc.event.running
          });
          break;
        case LangGraphEventTypes.OnChatModelStream:
          if (acc.isToolCallStart && this.shouldEmitToolCall(shouldEmitToolCalls, acc.lastToolCallName)) {
            events.push({
              type: RuntimeEventTypes.ActionExecutionStart,
              actionExecutionId: acc.lastToolCallId,
              actionName: acc.lastToolCallName,
              parentMessageId: acc.lastMessageId
            });
          } else if (acc.isMessageStart && shouldEmitMessages) {
            acc.processedToolCallIds.clear();
            events.push({
              type: RuntimeEventTypes.TextMessageStart,
              messageId: acc.lastMessageId
            });
          }
          if (acc.isToolCall && acc.currentContent && this.shouldEmitToolCall(shouldEmitToolCalls, acc.lastToolCallName)) {
            events.push({
              type: RuntimeEventTypes.ActionExecutionArgs,
              actionExecutionId: acc.lastToolCallId,
              args: acc.currentContent
            });
          } else if (!acc.isToolCall && acc.currentContent && shouldEmitMessages) {
            events.push({
              type: RuntimeEventTypes.TextMessageContent,
              messageId: acc.lastMessageId,
              content: acc.currentContent
            });
          }
          break;
      }
      return events;
    }), catchError((error) => {
      if (isStructuredCopilotKitError(error)) {
        throw error;
      }
      let helpfulMessage = generateHelpfulErrorMessage(error, "LangGraph agent connection");
      throw new CopilotKitLowLevelError4({
        error: error instanceof Error ? error : new Error(String(error)),
        url: "langgraph event stream",
        message: helpfulMessage
      });
    }));
  }
};
__name(RemoteLangGraphEventSource, "RemoteLangGraphEventSource");

// src/lib/runtime/remote-action-constructors.ts
import { CopilotKitError as CopilotKitError4, CopilotKitLowLevelError as CopilotKitLowLevelError5 } from "@copilotkit/shared";
import { CopilotKitApiDiscoveryError as CopilotKitApiDiscoveryError2, ResolvedCopilotKitError as ResolvedCopilotKitError2 } from "@copilotkit/shared";
import { parseJson as parseJson2, tryMap as tryMap2 } from "@copilotkit/shared";
function constructLGCRemoteAction({ endpoint, graphqlContext, logger: logger2, messages, agentStates }) {
  const agents = endpoint.agents.map((agent) => ({
    name: agent.name,
    description: agent.description,
    parameters: [],
    handler: async (_args) => {
    },
    remoteAgentHandler: async ({ name, actionInputsWithoutAgents, threadId, nodeName, additionalMessages = [], metaEvents }) => {
      logger2.debug({
        actionName: agent.name
      }, "Executing LangGraph Platform agent");
      telemetry_client_default.capture("oss.runtime.remote_action_executed", {
        agentExecution: true,
        type: "langgraph-platform",
        agentsAmount: endpoint.agents.length,
        hashedLgcKey: endpoint.langsmithApiKey ? createHash3("sha256").update(endpoint.langsmithApiKey).digest("hex") : null
      });
      let state = {};
      let config = {};
      if (agentStates) {
        const jsonState = agentStates.find((state2) => state2.agentName === name);
        if (jsonState) {
          state = parseJson2(jsonState.state, {});
          config = parseJson2(jsonState.config, {});
        }
      }
      try {
        const response = await execute({
          logger: logger2.child({
            component: "remote-actions.remote-lg-action.streamEvents"
          }),
          deploymentUrl: endpoint.deploymentUrl,
          langsmithApiKey: endpoint.langsmithApiKey,
          agent,
          threadId,
          nodeName,
          messages: [
            ...messages,
            ...additionalMessages
          ],
          state,
          config,
          properties: graphqlContext.properties,
          actions: tryMap2(actionInputsWithoutAgents, (action) => ({
            name: action.name,
            description: action.description,
            parameters: JSON.parse(action.jsonSchema)
          })),
          metaEvents
        });
        const eventSource = new RemoteLangGraphEventSource();
        writeJsonLineResponseToEventStream(response, eventSource.eventStream$);
        return eventSource.processLangGraphEvents();
      } catch (error) {
        if (error instanceof CopilotKitError4 || error instanceof CopilotKitLowLevelError5) {
          if (isUserConfigurationError(error)) {
            logger2.debug({
              url: endpoint.deploymentUrl,
              error: error.message,
              code: error.code
            }, "User configuration error in LangGraph Platform agent");
          } else {
            logger2.error({
              url: endpoint.deploymentUrl,
              error: error.message,
              type: error.constructor.name
            }, "LangGraph Platform agent error");
          }
          throw error;
        }
        logger2.error({
          url: endpoint.deploymentUrl,
          status: 500,
          body: error.message
        }, "Failed to execute LangGraph Platform agent");
        throw new CopilotKitLowLevelError5({
          error: error instanceof Error ? error : new Error(String(error)),
          url: endpoint.deploymentUrl,
          message: "Failed to execute LangGraph Platform agent"
        });
      }
    }
  }));
  return [
    ...agents
  ];
}
__name(constructLGCRemoteAction, "constructLGCRemoteAction");
var RemoteAgentType;
(function(RemoteAgentType2) {
  RemoteAgentType2["LangGraph"] = "langgraph";
  RemoteAgentType2["CrewAI"] = "crewai";
})(RemoteAgentType || (RemoteAgentType = {}));
function constructRemoteActions({ json, url, onBeforeRequest, graphqlContext, logger: logger2, messages, agentStates }) {
  const totalAgents = Array.isArray(json["agents"]) ? json["agents"].length : 0;
  const actions = json["actions"].map((action) => ({
    name: action.name,
    description: action.description,
    parameters: action.parameters,
    handler: async (args) => {
      logger2.debug({
        actionName: action.name,
        args
      }, "Executing remote action");
      const headers = createHeaders(onBeforeRequest, graphqlContext);
      telemetry_client_default.capture("oss.runtime.remote_action_executed", {
        agentExecution: false,
        type: "self-hosted",
        agentsAmount: totalAgents
      });
      const fetchUrl = `${url}/actions/execute`;
      try {
        const response = await fetchWithRetry(fetchUrl, {
          method: "POST",
          headers,
          body: JSON.stringify({
            name: action.name,
            arguments: args,
            properties: graphqlContext.properties
          })
        }, logger2);
        if (!response.ok) {
          logger2.error({
            url,
            status: response.status,
            body: await response.text()
          }, "Failed to execute remote action");
          if (response.status === 404) {
            throw new CopilotKitApiDiscoveryError2({
              url: fetchUrl
            });
          }
          throw new ResolvedCopilotKitError2({
            status: response.status,
            url: fetchUrl,
            isRemoteEndpoint: true
          });
        }
        const requestResult = await response.json();
        const result = requestResult["result"];
        logger2.debug({
          actionName: action.name,
          result
        }, "Executed remote action");
        return result;
      } catch (error) {
        if (error instanceof CopilotKitError4 || error instanceof CopilotKitLowLevelError5) {
          throw error;
        }
        throw new CopilotKitLowLevelError5({
          error,
          url: fetchUrl
        });
      }
    }
  }));
  const agents = totalAgents ? json["agents"].map((agent) => ({
    name: agent.name,
    description: agent.description,
    parameters: [],
    handler: async (_args) => {
    },
    remoteAgentHandler: async ({ name, actionInputsWithoutAgents, threadId, nodeName, additionalMessages = [], metaEvents }) => {
      logger2.debug({
        actionName: agent.name
      }, "Executing remote agent");
      const headers = createHeaders(onBeforeRequest, graphqlContext);
      telemetry_client_default.capture("oss.runtime.remote_action_executed", {
        agentExecution: true,
        type: "self-hosted",
        agentsAmount: json["agents"].length
      });
      let state = {};
      let config = {};
      if (agentStates) {
        const jsonState = agentStates.find((state2) => state2.agentName === name);
        if (jsonState) {
          state = parseJson2(jsonState.state, {});
          config = parseJson2(jsonState.config, {});
        }
      }
      const fetchUrl = `${url}/agents/execute`;
      try {
        const response = await fetchWithRetry(fetchUrl, {
          method: "POST",
          headers,
          body: JSON.stringify({
            name,
            threadId,
            nodeName,
            messages: [
              ...messages,
              ...additionalMessages
            ],
            state,
            config,
            properties: graphqlContext.properties,
            actions: tryMap2(actionInputsWithoutAgents, (action) => ({
              name: action.name,
              description: action.description,
              parameters: JSON.parse(action.jsonSchema)
            })),
            metaEvents
          })
        }, logger2);
        if (!response.ok) {
          logger2.error({
            url,
            status: response.status,
            body: await response.text()
          }, "Failed to execute remote agent");
          if (response.status === 404) {
            throw new CopilotKitApiDiscoveryError2({
              url: fetchUrl
            });
          }
          throw new ResolvedCopilotKitError2({
            status: response.status,
            url: fetchUrl,
            isRemoteEndpoint: true
          });
        }
        if (agent.type === "langgraph") {
          const eventSource = new RemoteLangGraphEventSource();
          writeJsonLineResponseToEventStream(response.body, eventSource.eventStream$);
          return eventSource.processLangGraphEvents();
        } else if (agent.type === "crewai") {
          const eventStream$ = new RuntimeEventSubject();
          writeJsonLineResponseToEventStream(response.body, eventStream$);
          return eventStream$;
        } else {
          throw new Error("Unsupported agent type");
        }
      } catch (error) {
        if (error instanceof CopilotKitError4 || error instanceof CopilotKitLowLevelError5) {
          throw error;
        }
        throw new CopilotKitLowLevelError5({
          error,
          url: fetchUrl
        });
      }
    }
  })) : [];
  return [
    ...actions,
    ...agents
  ];
}
__name(constructRemoteActions, "constructRemoteActions");
function createHeaders(onBeforeRequest, graphqlContext) {
  const headers = {
    "Content-Type": "application/json"
  };
  if (onBeforeRequest) {
    const { headers: additionalHeaders } = onBeforeRequest({
      ctx: graphqlContext
    });
    if (additionalHeaders) {
      Object.assign(headers, additionalHeaders);
    }
  }
  return headers;
}
__name(createHeaders, "createHeaders");

// src/lib/runtime/remote-actions.ts
import { CopilotKitLowLevelError as CopilotKitLowLevelError6, ResolvedCopilotKitError as ResolvedCopilotKitError3, CopilotKitError as CopilotKitError5 } from "@copilotkit/shared";

// src/lib/runtime/agui-action.ts
import { parseJson as parseJson3 } from "@copilotkit/shared";
function constructAGUIRemoteAction({ logger: logger2, messages, agentStates, agent, metaEvents, threadMetadata, nodeName }) {
  const action = {
    name: agent.agentId,
    description: agent.description,
    parameters: [],
    handler: async (_args) => {
    },
    remoteAgentHandler: async ({ actionInputsWithoutAgents, threadId }) => {
      var _a;
      logger2.debug({
        actionName: agent.agentId
      }, "Executing remote agent");
      const agentWireMessages = convertMessagesToAGUIMessage(messages);
      agent.messages = agentWireMessages;
      agent.threadId = threadId;
      telemetry_client_default.capture("oss.runtime.remote_action_executed", {
        agentExecution: true,
        type: "self-hosted",
        agentsAmount: 1
      });
      let state = {};
      if (agentStates) {
        const jsonState = agentStates.find((state2) => state2.agentName === agent.agentId);
        if (jsonState) {
          state = parseJson3(jsonState.state, {});
        }
      }
      agent.state = state;
      const tools = actionInputsWithoutAgents.map((input) => {
        return {
          name: input.name,
          description: input.description,
          parameters: JSON.parse(input.jsonSchema)
        };
      });
      const forwardedProps = {
        ...(metaEvents == null ? void 0 : metaEvents.length) ? {
          command: {
            resume: (_a = metaEvents[0]) == null ? void 0 : _a.response
          }
        } : {},
        ...threadMetadata ? {
          threadMetadata
        } : {},
        ...nodeName ? {
          nodeName
        } : {}
      };
      return agent.legacy_to_be_removed_runAgentBridged({
        tools,
        forwardedProps
      });
    }
  };
  return [
    action
  ];
}
__name(constructAGUIRemoteAction, "constructAGUIRemoteAction");
function convertMessagesToAGUIMessage(messages) {
  const result = [];
  for (const message of messages) {
    if (message.isTextMessage()) {
      result.push({
        id: message.id,
        role: message.role,
        content: message.content
      });
    } else if (message.isActionExecutionMessage()) {
      const toolCall = {
        id: message.id,
        type: "function",
        function: {
          name: message.name,
          arguments: JSON.stringify(message.arguments)
        }
      };
      if (message.parentMessageId && result.some((m) => m.id === message.parentMessageId)) {
        const parentMessage = result.find((m) => m.id === message.parentMessageId);
        if (parentMessage.toolCalls === void 0) {
          parentMessage.toolCalls = [];
        }
        parentMessage.toolCalls.push(toolCall);
      } else {
        result.push({
          id: message.parentMessageId ?? message.id,
          role: "assistant",
          toolCalls: [
            toolCall
          ]
        });
      }
    } else if (message.isResultMessage()) {
      result.push({
        id: message.id,
        role: "tool",
        content: message.result,
        toolCallId: message.actionExecutionId
      });
    }
  }
  return result;
}
__name(convertMessagesToAGUIMessage, "convertMessagesToAGUIMessage");

// src/lib/runtime/remote-actions.ts
var EndpointType;
(function(EndpointType2) {
  EndpointType2["CopilotKit"] = "copilotKit";
  EndpointType2["LangGraphPlatform"] = "langgraph-platform";
})(EndpointType || (EndpointType = {}));
function isRemoteAgentAction(action) {
  if (!action) {
    return false;
  }
  return typeof action.remoteAgentHandler === "function";
}
__name(isRemoteAgentAction, "isRemoteAgentAction");
async function fetchRemoteInfo({ url, onBeforeRequest, graphqlContext, logger: logger2, frontendUrl }) {
  logger2.debug({
    url
  }, "Fetching actions from url");
  const headers = createHeaders(onBeforeRequest, graphqlContext);
  const fetchUrl = `${url}/info`;
  try {
    const response = await fetch(fetchUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({
        properties: graphqlContext.properties,
        frontendUrl
      })
    });
    if (!response.ok) {
      logger2.error({
        url,
        status: response.status,
        body: await response.text()
      }, "Failed to fetch actions from url");
      throw new ResolvedCopilotKitError3({
        status: response.status,
        url: fetchUrl,
        isRemoteEndpoint: true
      });
    }
    const json = await response.json();
    logger2.debug({
      json
    }, "Fetched actions from url");
    return json;
  } catch (error) {
    if (error instanceof CopilotKitError5) {
      throw error;
    }
    throw new CopilotKitLowLevelError6({
      error,
      url: fetchUrl
    });
  }
}
__name(fetchRemoteInfo, "fetchRemoteInfo");
async function setupRemoteActions({ remoteEndpointDefinitions, graphqlContext, messages, agentStates, frontendUrl, agents, metaEvents, nodeName }) {
  var _a;
  const logger2 = graphqlContext.logger.child({
    component: "remote-actions.fetchRemoteActions"
  });
  logger2.debug({
    remoteEndpointDefinitions
  }, "Fetching from remote endpoints");
  const threadMetadata = ((_a = graphqlContext.properties) == null ? void 0 : _a.threadMetadata) || {};
  const filtered = remoteEndpointDefinitions.filter((value, index, self) => {
    if (value.type === "langgraph-platform") {
      return value;
    }
    return index === self.findIndex((t) => t.url === value.url);
  });
  const result = await Promise.all(filtered.map(async (endpoint) => {
    if (endpoint.type === "langgraph-platform") {
      return constructLGCRemoteAction({
        endpoint,
        messages,
        graphqlContext,
        logger: logger2.child({
          component: "remote-actions.constructLGCRemoteAction",
          endpoint
        }),
        agentStates
      });
    }
    const json = await fetchRemoteInfo({
      url: endpoint.url,
      onBeforeRequest: endpoint.onBeforeRequest,
      graphqlContext,
      logger: logger2.child({
        component: "remote-actions.fetchActionsFromUrl",
        endpoint
      }),
      frontendUrl
    });
    return constructRemoteActions({
      json,
      messages,
      url: endpoint.url,
      onBeforeRequest: endpoint.onBeforeRequest,
      graphqlContext,
      logger: logger2.child({
        component: "remote-actions.constructActions",
        endpoint
      }),
      agentStates
    });
  }));
  for (const [key, agent] of Object.entries(agents)) {
    if (agent.agentId !== void 0 && agent.agentId !== key) {
      throw new CopilotKitError5({
        message: `Agent ${key} has agentId ${agent.agentId} which does not match the key ${key}`,
        code: CopilotKitErrorCode3.UNKNOWN
      });
    } else if (agent.agentId === void 0) {
      agent.agentId = key;
    }
    result.push(constructAGUIRemoteAction({
      logger: logger2,
      messages,
      agentStates,
      agent,
      metaEvents,
      threadMetadata,
      nodeName
    }));
  }
  return result.flat();
}
__name(setupRemoteActions, "setupRemoteActions");

// src/service-adapters/events.ts
var RuntimeEventTypes;
(function(RuntimeEventTypes2) {
  RuntimeEventTypes2["TextMessageStart"] = "TextMessageStart";
  RuntimeEventTypes2["TextMessageContent"] = "TextMessageContent";
  RuntimeEventTypes2["TextMessageEnd"] = "TextMessageEnd";
  RuntimeEventTypes2["ActionExecutionStart"] = "ActionExecutionStart";
  RuntimeEventTypes2["ActionExecutionArgs"] = "ActionExecutionArgs";
  RuntimeEventTypes2["ActionExecutionEnd"] = "ActionExecutionEnd";
  RuntimeEventTypes2["ActionExecutionResult"] = "ActionExecutionResult";
  RuntimeEventTypes2["AgentStateMessage"] = "AgentStateMessage";
  RuntimeEventTypes2["MetaEvent"] = "MetaEvent";
})(RuntimeEventTypes || (RuntimeEventTypes = {}));
var RuntimeMetaEventName;
(function(RuntimeMetaEventName2) {
  RuntimeMetaEventName2["LangGraphInterruptEvent"] = "LangGraphInterruptEvent";
  RuntimeMetaEventName2["LangGraphInterruptResumeEvent"] = "LangGraphInterruptResumeEvent";
  RuntimeMetaEventName2["CopilotKitLangGraphInterruptEvent"] = "CopilotKitLangGraphInterruptEvent";
})(RuntimeMetaEventName || (RuntimeMetaEventName = {}));
var RuntimeEventSubject = class extends ReplaySubject2 {
  constructor() {
    super();
  }
  sendTextMessageStart({ messageId, parentMessageId }) {
    this.next({
      type: "TextMessageStart",
      messageId,
      parentMessageId
    });
  }
  sendTextMessageContent({ messageId, content }) {
    this.next({
      type: "TextMessageContent",
      content,
      messageId
    });
  }
  sendTextMessageEnd({ messageId }) {
    this.next({
      type: "TextMessageEnd",
      messageId
    });
  }
  sendTextMessage(messageId, content) {
    this.sendTextMessageStart({
      messageId
    });
    this.sendTextMessageContent({
      messageId,
      content
    });
    this.sendTextMessageEnd({
      messageId
    });
  }
  sendActionExecutionStart({ actionExecutionId, actionName, parentMessageId }) {
    this.next({
      type: "ActionExecutionStart",
      actionExecutionId,
      actionName,
      parentMessageId
    });
  }
  sendActionExecutionArgs({ actionExecutionId, args }) {
    this.next({
      type: "ActionExecutionArgs",
      args,
      actionExecutionId
    });
  }
  sendActionExecutionEnd({ actionExecutionId }) {
    this.next({
      type: "ActionExecutionEnd",
      actionExecutionId
    });
  }
  sendActionExecution({ actionExecutionId, actionName, args, parentMessageId }) {
    this.sendActionExecutionStart({
      actionExecutionId,
      actionName,
      parentMessageId
    });
    this.sendActionExecutionArgs({
      actionExecutionId,
      args
    });
    this.sendActionExecutionEnd({
      actionExecutionId
    });
  }
  sendActionExecutionResult({ actionExecutionId, actionName, result, error }) {
    this.next({
      type: "ActionExecutionResult",
      actionName,
      actionExecutionId,
      result: ResultMessage.encodeResult(result, error)
    });
  }
  sendAgentStateMessage({ threadId, agentName, nodeName, runId, active, role, state, running }) {
    this.next({
      type: "AgentStateMessage",
      threadId,
      agentName,
      nodeName,
      runId,
      active,
      role,
      state,
      running
    });
  }
};
__name(RuntimeEventSubject, "RuntimeEventSubject");
var RuntimeEventSource = class {
  eventStream$ = new RuntimeEventSubject();
  callback;
  errorHandler;
  errorContext;
  constructor(params) {
    this.errorHandler = params == null ? void 0 : params.errorHandler;
    this.errorContext = params == null ? void 0 : params.errorContext;
  }
  async stream(callback) {
    this.callback = callback;
  }
  sendErrorMessageToChat(message = "An error occurred. Please try again.") {
    const errorMessage = `\u274C ${message}`;
    if (!this.callback) {
      this.stream(async (eventStream$) => {
        eventStream$.sendTextMessage(randomId2(), errorMessage);
      });
    } else {
      this.eventStream$.sendTextMessage(randomId2(), errorMessage);
    }
  }
  processRuntimeEvents({ serverSideActions, guardrailsResult$, actionInputsWithoutAgents, threadId }) {
    this.callback(this.eventStream$).catch(async (error) => {
      const structuredError = ensureStructuredError3(error, convertStreamingErrorToStructured2);
      if (this.errorHandler && this.errorContext) {
        try {
          await this.errorHandler(structuredError, this.errorContext);
        } catch (errorHandlerError) {
          console.error("Error in streaming error handler:", errorHandlerError);
        }
      }
      this.eventStream$.error(structuredError);
      this.eventStream$.complete();
    });
    return this.eventStream$.pipe(
      // track state
      scan2((acc, event) => {
        acc = {
          ...acc
        };
        if (event.type === "ActionExecutionStart") {
          acc.callActionServerSide = serverSideActions.find((action) => action.name === event.actionName) !== void 0;
          acc.args = "";
          acc.actionExecutionId = event.actionExecutionId;
          if (acc.callActionServerSide) {
            acc.action = serverSideActions.find((action) => action.name === event.actionName);
          }
          acc.actionExecutionParentMessageId = event.parentMessageId;
        } else if (event.type === "ActionExecutionArgs") {
          acc.args += event.args;
        }
        acc.event = event;
        return acc;
      }, {
        event: null,
        callActionServerSide: false,
        args: "",
        actionExecutionId: null,
        action: null,
        actionExecutionParentMessageId: null
      }),
      concatMap((eventWithState) => {
        if (eventWithState.event.type === "ActionExecutionEnd" && eventWithState.callActionServerSide) {
          const toolCallEventStream$ = new RuntimeEventSubject();
          executeAction(toolCallEventStream$, guardrailsResult$ ? guardrailsResult$ : null, eventWithState.action, eventWithState.args, eventWithState.actionExecutionParentMessageId, eventWithState.actionExecutionId, actionInputsWithoutAgents, threadId).catch((error) => {
          });
          telemetry_client_default.capture("oss.runtime.server_action_executed", {});
          return concat(of(eventWithState.event), toolCallEventStream$).pipe(catchError2((error) => {
            const structuredError = ensureStructuredError3(error, convertStreamingErrorToStructured2);
            if (this.errorHandler && this.errorContext) {
              from2(this.errorHandler(structuredError, {
                ...this.errorContext,
                action: {
                  name: eventWithState.action.name,
                  executionId: eventWithState.actionExecutionId
                }
              })).subscribe({
                error: (errorHandlerError) => {
                  console.error("Error in action execution error handler:", errorHandlerError);
                }
              });
            }
            toolCallEventStream$.sendActionExecutionResult({
              actionExecutionId: eventWithState.actionExecutionId,
              actionName: eventWithState.action.name,
              error: {
                code: structuredError.code,
                message: structuredError.message
              }
            });
            return EMPTY;
          }));
        } else {
          return of(eventWithState.event);
        }
      })
    );
  }
};
__name(RuntimeEventSource, "RuntimeEventSource");
async function executeAction(eventStream$, guardrailsResult$, action, actionArguments, actionExecutionParentMessageId, actionExecutionId, actionInputsWithoutAgents, threadId) {
  var _a;
  if (guardrailsResult$) {
    const { status } = await firstValueFrom(guardrailsResult$);
    if (status === "denied") {
      eventStream$.complete();
      return;
    }
  }
  let args = [];
  if (actionArguments) {
    try {
      args = JSON.parse(actionArguments);
    } catch (e) {
      console.error("Action argument unparsable", {
        actionArguments
      });
      eventStream$.sendActionExecutionResult({
        actionExecutionId,
        actionName: action.name,
        error: {
          code: "INVALID_ARGUMENTS",
          message: "Failed to parse action arguments"
        }
      });
      return;
    }
  }
  if (isRemoteAgentAction(action)) {
    const result = `${action.name} agent started`;
    const agentExecution = plainToInstance2(ActionExecutionMessage, {
      id: actionExecutionId,
      createdAt: /* @__PURE__ */ new Date(),
      name: action.name,
      arguments: JSON.parse(actionArguments),
      parentMessageId: actionExecutionParentMessageId ?? actionExecutionId
    });
    const agentExecutionResult = plainToInstance2(ResultMessage, {
      id: "result-" + actionExecutionId,
      createdAt: /* @__PURE__ */ new Date(),
      actionExecutionId,
      actionName: action.name,
      result
    });
    eventStream$.sendActionExecutionResult({
      actionExecutionId,
      actionName: action.name,
      result
    });
    const stream = await action.remoteAgentHandler({
      name: action.name,
      threadId,
      actionInputsWithoutAgents,
      additionalMessages: [
        agentExecution,
        agentExecutionResult
      ]
    });
    from2(stream).subscribe({
      next: (event) => eventStream$.next(event),
      error: (err) => {
        const structuredError = ensureStructuredError3(err, convertStreamingErrorToStructured2);
        eventStream$.sendActionExecutionResult({
          actionExecutionId,
          actionName: action.name,
          error: {
            code: structuredError.code,
            message: structuredError.message
          }
        });
        eventStream$.complete();
      },
      complete: () => eventStream$.complete()
    });
  } else {
    try {
      const result = await ((_a = action.handler) == null ? void 0 : _a.call(action, args));
      await streamLangChainResponse({
        result,
        eventStream$,
        actionExecution: {
          name: action.name,
          id: actionExecutionId
        }
      });
    } catch (e) {
      console.error("Error in action handler", e);
      eventStream$.sendActionExecutionResult({
        actionExecutionId,
        actionName: action.name,
        error: {
          code: "HANDLER_ERROR",
          message: e.message
        }
      });
      eventStream$.complete();
    }
  }
}
__name(executeAction, "executeAction");
function convertStreamingErrorToStructured2(error) {
  var _a, _b, _c, _d, _e, _f, _g;
  let helpfulMessage = generateHelpfulErrorMessage(error, "event streaming connection");
  if (((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes("fetch failed")) || ((_b = error == null ? void 0 : error.message) == null ? void 0 : _b.includes("ECONNREFUSED")) || ((_c = error == null ? void 0 : error.message) == null ? void 0 : _c.includes("ENOTFOUND")) || ((_d = error == null ? void 0 : error.message) == null ? void 0 : _d.includes("ETIMEDOUT")) || ((_e = error == null ? void 0 : error.message) == null ? void 0 : _e.includes("terminated")) || ((_f = error == null ? void 0 : error.cause) == null ? void 0 : _f.code) === "UND_ERR_SOCKET" || ((_g = error == null ? void 0 : error.message) == null ? void 0 : _g.includes("other side closed")) || (error == null ? void 0 : error.code) === "UND_ERR_SOCKET") {
    return new CopilotKitLowLevelError7({
      error: error instanceof Error ? error : new Error(String(error)),
      url: "event streaming connection",
      message: helpfulMessage
    });
  }
  return new CopilotKitError6({
    message: helpfulMessage,
    code: CopilotKitErrorCode4.UNKNOWN,
    severity: Severity.CRITICAL
  });
}
__name(convertStreamingErrorToStructured2, "convertStreamingErrorToStructured");

// src/graphql/resolvers/copilot.resolver.ts
import { GraphQLJSONObject } from "graphql-scalars";
import { plainToInstance as plainToInstance3 } from "class-transformer";
import { GraphQLError } from "graphql";
import { randomId as randomId3 } from "@copilotkit/shared";

// src/graphql/types/agents-response.type.ts
import { Field as Field16, ObjectType as ObjectType5 } from "type-graphql";
function _ts_decorate16(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate16, "_ts_decorate");
function _ts_metadata16(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata16, "_ts_metadata");
var Agent = class {
  id;
  name;
  description;
};
__name(Agent, "Agent");
_ts_decorate16([
  Field16(() => String),
  _ts_metadata16("design:type", String)
], Agent.prototype, "id", void 0);
_ts_decorate16([
  Field16(() => String),
  _ts_metadata16("design:type", String)
], Agent.prototype, "name", void 0);
_ts_decorate16([
  Field16(() => String),
  _ts_metadata16("design:type", String)
], Agent.prototype, "description", void 0);
Agent = _ts_decorate16([
  ObjectType5()
], Agent);
var AgentsResponse = class {
  agents;
};
__name(AgentsResponse, "AgentsResponse");
_ts_decorate16([
  Field16(() => [
    Agent
  ]),
  _ts_metadata16("design:type", Array)
], AgentsResponse.prototype, "agents", void 0);
AgentsResponse = _ts_decorate16([
  ObjectType5()
], AgentsResponse);

// src/graphql/resolvers/copilot.resolver.ts
import { CopilotKitError as CopilotKitError7, CopilotKitLowLevelError as CopilotKitLowLevelError8, isStructuredCopilotKitError as isStructuredCopilotKitError2 } from "@copilotkit/shared";
function _ts_decorate17(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate17, "_ts_decorate");
function _ts_metadata17(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata17, "_ts_metadata");
function _ts_param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
__name(_ts_param, "_ts_param");
var invokeGuardrails = /* @__PURE__ */ __name(async ({ baseUrl, copilotCloudPublicApiKey, data, onResult, onError }) => {
  var _a;
  if (data.messages.length && ((_a = data.messages[data.messages.length - 1].textMessage) == null ? void 0 : _a.role) === MessageRole.user) {
    const messages = data.messages.filter((m) => m.textMessage !== void 0 && (m.textMessage.role === MessageRole.user || m.textMessage.role === MessageRole.assistant)).map((m) => ({
      role: m.textMessage.role,
      content: m.textMessage.content
    }));
    const lastMessage = messages[messages.length - 1];
    const restOfMessages = messages.slice(0, -1);
    const body = {
      input: lastMessage.content,
      validTopics: data.cloud.guardrails.inputValidationRules.allowList,
      invalidTopics: data.cloud.guardrails.inputValidationRules.denyList,
      messages: restOfMessages
    };
    const guardrailsResult = await fetch(`${baseUrl}/guardrails/validate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CopilotCloud-Public-API-Key": copilotCloudPublicApiKey
      },
      body: JSON.stringify(body)
    });
    if (guardrailsResult.ok) {
      const resultJson = await guardrailsResult.json();
      onResult(resultJson);
    } else {
      onError(await guardrailsResult.json());
    }
  }
}, "invokeGuardrails");
var CopilotResolver = class {
  async hello() {
    return "Hello World";
  }
  async availableAgents(ctx) {
    let logger2 = ctx.logger.child({
      component: "CopilotResolver.availableAgents"
    });
    logger2.debug("Processing");
    const agentsWithEndpoints = await ctx._copilotkit.runtime.discoverAgentsFromEndpoints(ctx);
    logger2.debug("Event source created, creating response");
    return {
      agents: agentsWithEndpoints.map(({ endpoint, ...agentWithoutEndpoint }) => agentWithoutEndpoint)
    };
  }
  async generateCopilotResponse(ctx, data, properties) {
    var _a, _b, _c, _d, _e, _f, _g;
    telemetry_client_default.capture("oss.runtime.copilot_request_created", {
      "cloud.guardrails.enabled": ((_a = data.cloud) == null ? void 0 : _a.guardrails) !== void 0,
      requestType: data.metadata.requestType,
      "cloud.api_key_provided": !!ctx.request.headers.get("x-copilotcloud-public-api-key"),
      ...ctx.request.headers.get("x-copilotcloud-public-api-key") ? {
        "cloud.public_api_key": ctx.request.headers.get("x-copilotcloud-public-api-key")
      } : {},
      ...ctx._copilotkit.baseUrl ? {
        "cloud.base_url": ctx._copilotkit.baseUrl
      } : {
        "cloud.base_url": "https://api.cloud.copilotkit.ai"
      }
    });
    let logger2 = ctx.logger.child({
      component: "CopilotResolver.generateCopilotResponse"
    });
    logger2.debug({
      data
    }, "Generating Copilot response");
    if (properties) {
      logger2.debug("Properties provided, merging with context properties");
      ctx.properties = {
        ...ctx.properties,
        ...properties
      };
    }
    const copilotRuntime = ctx._copilotkit.runtime;
    const serviceAdapter = ctx._copilotkit.serviceAdapter;
    let copilotCloudPublicApiKey = null;
    let copilotCloudBaseUrl;
    const publicApiKeyFromHeaders = ctx.request.headers.get("x-copilotcloud-public-api-key");
    if (publicApiKeyFromHeaders) {
      copilotCloudPublicApiKey = publicApiKeyFromHeaders;
    }
    if (data.cloud) {
      logger2 = logger2.child({
        cloud: true
      });
      logger2.debug("Cloud configuration provided, checking for public API key in headers");
      if (!copilotCloudPublicApiKey) {
        logger2.error("Public API key not found in headers");
        await copilotRuntime.errorGraphQLError({
          message: "X-CopilotCloud-Public-API-Key header is required",
          code: "MISSING_PUBLIC_API_KEY",
          type: "GraphQLError"
        }, {
          operation: "generateCopilotResponse",
          cloudConfigPresent: Boolean(data.cloud),
          guardrailsEnabled: Boolean((_b = data.cloud) == null ? void 0 : _b.guardrails)
        });
        throw new GraphQLError("X-CopilotCloud-Public-API-Key header is required");
      }
      if (process.env.COPILOT_CLOUD_BASE_URL) {
        copilotCloudBaseUrl = process.env.COPILOT_CLOUD_BASE_URL;
      } else if ((_c = ctx._copilotkit.cloud) == null ? void 0 : _c.baseUrl) {
        copilotCloudBaseUrl = (_d = ctx._copilotkit.cloud) == null ? void 0 : _d.baseUrl;
      } else {
        copilotCloudBaseUrl = "https://api.cloud.copilotkit.ai";
      }
      logger2 = logger2.child({
        copilotCloudBaseUrl
      });
    }
    logger2.debug("Setting up subjects");
    const responseStatus$ = new ReplaySubject3();
    const interruptStreaming$ = new ReplaySubject3();
    const guardrailsResult$ = new ReplaySubject3();
    let outputMessages = [];
    let resolveOutputMessagesPromise;
    let rejectOutputMessagesPromise;
    const outputMessagesPromise = new Promise((resolve, reject) => {
      resolveOutputMessagesPromise = resolve;
      rejectOutputMessagesPromise = reject;
    });
    if (copilotCloudPublicApiKey) {
      ctx.properties["copilotCloudPublicApiKey"] = copilotCloudPublicApiKey;
    }
    logger2.debug("Processing");
    let runtimeResponse;
    try {
      runtimeResponse = await copilotRuntime.processRuntimeRequest({
        serviceAdapter,
        messages: data.messages,
        actions: data.frontend.actions.filter((action) => action.available !== ActionInputAvailability.disabled),
        threadId: data.threadId,
        runId: data.runId,
        publicApiKey: copilotCloudPublicApiKey,
        outputMessagesPromise,
        graphqlContext: ctx,
        forwardedParameters: data.forwardedParameters,
        agentSession: data.agentSession,
        agentStates: data.agentStates,
        url: data.frontend.url,
        extensions: data.extensions,
        metaEvents: data.metaEvents
      });
    } catch (error) {
      if (isStructuredCopilotKitError2(error) || ((_e = error == null ? void 0 : error.extensions) == null ? void 0 : _e.visibility)) {
        throw new GraphQLError(error.message || "Agent error occurred", {
          extensions: {
            ...error.extensions,
            code: error.code || ((_f = error.extensions) == null ? void 0 : _f.code) || "AGENT_ERROR",
            originalError: error
          }
        });
      }
      throw error;
    }
    const { eventSource, threadId = randomId3(), runId, serverSideActions, actionInputsWithoutAgents, extensions } = runtimeResponse;
    logger2.debug("Event source created, creating response");
    const eventStream = eventSource.processRuntimeEvents({
      serverSideActions,
      guardrailsResult$: ((_g = data.cloud) == null ? void 0 : _g.guardrails) ? guardrailsResult$ : null,
      actionInputsWithoutAgents: actionInputsWithoutAgents.filter(
        // TODO-AGENTS: do not exclude ALL server side actions
        (action) => !serverSideActions.find((serverSideAction) => serverSideAction.name == action.name)
      ),
      threadId
    }).pipe(
      // shareReplay() ensures that later subscribers will see the whole stream instead of
      // just the events that were emitted after the subscriber was added.
      shareReplay(),
      finalize(() => {
        logger2.debug("Event stream finalized");
      })
    );
    const response = {
      threadId,
      runId,
      status: firstValueFrom2(responseStatus$),
      extensions,
      metaEvents: new Repeater(async (push, stop) => {
        let eventStreamSubscription;
        eventStreamSubscription = eventStream.subscribe({
          next: async (event) => {
            if (event.type != RuntimeEventTypes.MetaEvent) {
              return;
            }
            switch (event.name) {
              case LangGraphEventTypes.OnInterrupt:
                push(plainToInstance3(LangGraphInterruptEvent, {
                  // @ts-ignore
                  type: event.type,
                  // @ts-ignore
                  name: RuntimeMetaEventName.LangGraphInterruptEvent,
                  // @ts-ignore
                  value: event.value
                }));
                break;
              case RuntimeMetaEventName.LangGraphInterruptEvent:
                push(plainToInstance3(LangGraphInterruptEvent, {
                  type: event.type,
                  name: event.name,
                  value: event.value
                }));
                break;
              case RuntimeMetaEventName.CopilotKitLangGraphInterruptEvent:
                push(plainToInstance3(CopilotKitLangGraphInterruptEvent, {
                  type: event.type,
                  name: event.name,
                  data: {
                    value: event.data.value,
                    messages: event.data.messages.map((message) => {
                      if (message.type === "TextMessage" || "content" in message && "role" in message) {
                        return plainToInstance3(TextMessage, {
                          id: message.id,
                          createdAt: /* @__PURE__ */ new Date(),
                          content: [
                            message.content
                          ],
                          role: message.role,
                          status: new SuccessMessageStatus()
                        });
                      }
                      if ("arguments" in message) {
                        return plainToInstance3(ActionExecutionMessage, {
                          name: message.name,
                          id: message.id,
                          arguments: [
                            JSON.stringify(message.arguments)
                          ],
                          createdAt: /* @__PURE__ */ new Date(),
                          status: new SuccessMessageStatus()
                        });
                      }
                      throw new Error("Unknown message in metaEvents copilot resolver");
                    })
                  }
                }));
                break;
            }
          },
          error: (err) => {
            var _a2, _b2;
            if (((_a2 = err == null ? void 0 : err.name) == null ? void 0 : _a2.includes("CopilotKit")) || ((_b2 = err == null ? void 0 : err.extensions) == null ? void 0 : _b2.visibility)) {
              responseStatus$.next(new UnknownErrorResponse({
                description: err.message || "Agent error occurred"
              }));
            } else {
              responseStatus$.next(new UnknownErrorResponse({
                description: `An unknown error has occurred in the event stream`
              }));
            }
            eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
            stop();
          },
          complete: async () => {
            logger2.debug("Meta events stream completed");
            responseStatus$.next(new SuccessResponseStatus());
            eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
            stop();
          }
        });
      }),
      messages: new Repeater(async (pushMessage, stopStreamingMessages) => {
        var _a2;
        logger2.debug("Messages repeater created");
        if ((_a2 = data.cloud) == null ? void 0 : _a2.guardrails) {
          logger2 = logger2.child({
            guardrails: true
          });
          logger2.debug("Guardrails is enabled, validating input");
          invokeGuardrails({
            baseUrl: copilotCloudBaseUrl,
            copilotCloudPublicApiKey,
            data,
            onResult: (result) => {
              logger2.debug({
                status: result.status
              }, "Guardrails validation done");
              guardrailsResult$.next(result);
              if (result.status === "denied") {
                responseStatus$.next(new GuardrailsValidationFailureResponse({
                  guardrailsReason: result.reason
                }));
                interruptStreaming$.next({
                  reason: `Interrupted due to Guardrails validation failure. Reason: ${result.reason}`
                });
                outputMessages = [
                  plainToInstance3(TextMessage, {
                    id: randomId3(),
                    createdAt: /* @__PURE__ */ new Date(),
                    content: result.reason,
                    role: MessageRole.assistant
                  })
                ];
                resolveOutputMessagesPromise(outputMessages);
              }
            },
            onError: (err) => {
              logger2.error({
                err
              }, "Error in guardrails validation");
              responseStatus$.next(new UnknownErrorResponse({
                description: `An unknown error has occurred in the guardrails validation`
              }));
              interruptStreaming$.next({
                reason: `Interrupted due to unknown error in guardrails validation`
              });
              rejectOutputMessagesPromise(err);
            }
          });
        }
        let eventStreamSubscription;
        logger2.debug("Event stream created, subscribing to event stream");
        eventStreamSubscription = eventStream.subscribe({
          next: async (event) => {
            switch (event.type) {
              case RuntimeEventTypes.MetaEvent:
                break;
              case RuntimeEventTypes.TextMessageStart:
                const textMessageContentStream = eventStream.pipe(
                  // skip until this message start event
                  skipWhile((e) => e !== event),
                  // take until the message end event
                  takeWhile((e) => !(e.type === RuntimeEventTypes.TextMessageEnd && e.messageId == event.messageId)),
                  // filter out any other message events or message ids
                  filter((e) => e.type == RuntimeEventTypes.TextMessageContent && e.messageId == event.messageId)
                );
                const streamingTextStatus = new Subject();
                const messageId = event.messageId;
                pushMessage({
                  id: messageId,
                  parentMessageId: event.parentMessageId,
                  status: firstValueFrom2(streamingTextStatus),
                  createdAt: /* @__PURE__ */ new Date(),
                  role: MessageRole.assistant,
                  content: new Repeater(async (pushTextChunk, stopStreamingText) => {
                    logger2.debug("Text message content repeater created");
                    const textChunks = [];
                    let textSubscription;
                    interruptStreaming$.pipe(shareReplay(), take(1), tap(({ reason, messageId: messageId2 }) => {
                      logger2.debug({
                        reason,
                        messageId: messageId2
                      }, "Text streaming interrupted");
                      streamingTextStatus.next(plainToInstance3(FailedMessageStatus, {
                        reason
                      }));
                      responseStatus$.next(new MessageStreamInterruptedResponse({
                        messageId: messageId2
                      }));
                      stopStreamingText();
                      textSubscription == null ? void 0 : textSubscription.unsubscribe();
                    })).subscribe();
                    logger2.debug("Subscribing to text message content stream");
                    textSubscription = textMessageContentStream.subscribe({
                      next: async (e) => {
                        if (e.type == RuntimeEventTypes.TextMessageContent) {
                          await pushTextChunk(e.content);
                          textChunks.push(e.content);
                        }
                      },
                      error: (err) => {
                        logger2.error({
                          err
                        }, "Error in text message content stream");
                        interruptStreaming$.next({
                          reason: "Error streaming message content",
                          messageId
                        });
                        stopStreamingText();
                        textSubscription == null ? void 0 : textSubscription.unsubscribe();
                      },
                      complete: () => {
                        logger2.debug("Text message content stream completed");
                        streamingTextStatus.next(new SuccessMessageStatus());
                        stopStreamingText();
                        textSubscription == null ? void 0 : textSubscription.unsubscribe();
                        outputMessages.push(plainToInstance3(TextMessage, {
                          id: messageId,
                          createdAt: /* @__PURE__ */ new Date(),
                          content: textChunks.join(""),
                          role: MessageRole.assistant
                        }));
                      }
                    });
                  })
                });
                break;
              case RuntimeEventTypes.ActionExecutionStart:
                logger2.debug("Action execution start event received");
                const actionExecutionArgumentStream = eventStream.pipe(
                  skipWhile((e) => e !== event),
                  // take until the action execution end event
                  takeWhile((e) => !(e.type === RuntimeEventTypes.ActionExecutionEnd && e.actionExecutionId == event.actionExecutionId)),
                  // filter out any other action execution events or action execution ids
                  filter((e) => e.type == RuntimeEventTypes.ActionExecutionArgs && e.actionExecutionId == event.actionExecutionId)
                );
                const streamingArgumentsStatus = new Subject();
                pushMessage({
                  id: event.actionExecutionId,
                  parentMessageId: event.parentMessageId,
                  status: firstValueFrom2(streamingArgumentsStatus),
                  createdAt: /* @__PURE__ */ new Date(),
                  name: event.actionName,
                  arguments: new Repeater(async (pushArgumentsChunk, stopStreamingArguments) => {
                    logger2.debug("Action execution argument stream created");
                    const argumentChunks = [];
                    let actionExecutionArgumentSubscription;
                    actionExecutionArgumentSubscription = actionExecutionArgumentStream.subscribe({
                      next: async (e) => {
                        if (e.type == RuntimeEventTypes.ActionExecutionArgs) {
                          await pushArgumentsChunk(e.args);
                          argumentChunks.push(e.args);
                        }
                      },
                      error: (err) => {
                        logger2.error({
                          err
                        }, "Error in action execution argument stream");
                        streamingArgumentsStatus.next(plainToInstance3(FailedMessageStatus, {
                          reason: "An unknown error has occurred in the action execution argument stream"
                        }));
                        stopStreamingArguments();
                        actionExecutionArgumentSubscription == null ? void 0 : actionExecutionArgumentSubscription.unsubscribe();
                      },
                      complete: () => {
                        logger2.debug("Action execution argument stream completed");
                        streamingArgumentsStatus.next(new SuccessMessageStatus());
                        stopStreamingArguments();
                        actionExecutionArgumentSubscription == null ? void 0 : actionExecutionArgumentSubscription.unsubscribe();
                        outputMessages.push(plainToInstance3(ActionExecutionMessage, {
                          id: event.actionExecutionId,
                          createdAt: /* @__PURE__ */ new Date(),
                          name: event.actionName,
                          arguments: argumentChunks.join("")
                        }));
                      }
                    });
                  })
                });
                break;
              case RuntimeEventTypes.ActionExecutionResult:
                logger2.debug({
                  result: event.result
                }, "Action execution result event received");
                pushMessage({
                  id: "result-" + event.actionExecutionId,
                  status: new SuccessMessageStatus(),
                  createdAt: /* @__PURE__ */ new Date(),
                  actionExecutionId: event.actionExecutionId,
                  actionName: event.actionName,
                  result: event.result
                });
                outputMessages.push(plainToInstance3(ResultMessage, {
                  id: "result-" + event.actionExecutionId,
                  createdAt: /* @__PURE__ */ new Date(),
                  actionExecutionId: event.actionExecutionId,
                  actionName: event.actionName,
                  result: event.result
                }));
                break;
              case RuntimeEventTypes.AgentStateMessage:
                logger2.debug({
                  event
                }, "Agent message event received");
                pushMessage({
                  id: randomId3(),
                  status: new SuccessMessageStatus(),
                  threadId: event.threadId,
                  agentName: event.agentName,
                  nodeName: event.nodeName,
                  runId: event.runId,
                  active: event.active,
                  state: event.state,
                  running: event.running,
                  role: MessageRole.assistant,
                  createdAt: /* @__PURE__ */ new Date()
                });
                outputMessages.push(plainToInstance3(AgentStateMessage, {
                  id: randomId3(),
                  threadId: event.threadId,
                  agentName: event.agentName,
                  nodeName: event.nodeName,
                  runId: event.runId,
                  active: event.active,
                  state: event.state,
                  running: event.running,
                  role: MessageRole.assistant,
                  createdAt: /* @__PURE__ */ new Date()
                }));
                break;
            }
          },
          error: (err) => {
            var _a3, _b2, _c2, _d2, _e2, _f2;
            if (err instanceof CopilotKitError7 || err instanceof CopilotKitLowLevelError8 || err instanceof Error && err.name && err.name.includes("CopilotKit") || ((_a3 = err == null ? void 0 : err.extensions) == null ? void 0 : _a3.visibility)) {
              responseStatus$.next(new UnknownErrorResponse({
                description: err.message || "Agent error occurred",
                // Include original error information for frontend to extract
                originalError: {
                  code: err.code || ((_b2 = err.extensions) == null ? void 0 : _b2.code),
                  statusCode: err.statusCode || ((_c2 = err.extensions) == null ? void 0 : _c2.statusCode),
                  severity: err.severity || ((_d2 = err.extensions) == null ? void 0 : _d2.severity),
                  visibility: err.visibility || ((_e2 = err.extensions) == null ? void 0 : _e2.visibility),
                  originalErrorType: err.originalErrorType || ((_f2 = err.extensions) == null ? void 0 : _f2.originalErrorType),
                  extensions: err.extensions
                }
              }));
              eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
              rejectOutputMessagesPromise(err);
              stopStreamingMessages();
              return;
            }
            responseStatus$.next(new UnknownErrorResponse({
              description: `An unknown error has occurred in the event stream`
            }));
            eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
            stopStreamingMessages();
            rejectOutputMessagesPromise(err);
          },
          complete: async () => {
            var _a3;
            logger2.debug("Event stream completed");
            if ((_a3 = data.cloud) == null ? void 0 : _a3.guardrails) {
              logger2.debug("Guardrails is enabled, waiting for guardrails result");
              await firstValueFrom2(guardrailsResult$);
            }
            responseStatus$.next(new SuccessResponseStatus());
            eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
            stopStreamingMessages();
            resolveOutputMessagesPromise(outputMessages);
          }
        });
      })
    };
    return response;
  }
};
__name(CopilotResolver, "CopilotResolver");
_ts_decorate17([
  Query(() => String),
  _ts_metadata17("design:type", Function),
  _ts_metadata17("design:paramtypes", []),
  _ts_metadata17("design:returntype", Promise)
], CopilotResolver.prototype, "hello", null);
_ts_decorate17([
  Query(() => AgentsResponse),
  _ts_param(0, Ctx()),
  _ts_metadata17("design:type", Function),
  _ts_metadata17("design:paramtypes", [
    typeof GraphQLContext === "undefined" ? Object : GraphQLContext
  ]),
  _ts_metadata17("design:returntype", Promise)
], CopilotResolver.prototype, "availableAgents", null);
_ts_decorate17([
  Mutation(() => CopilotResponse),
  _ts_param(0, Ctx()),
  _ts_param(1, Arg("data")),
  _ts_param(2, Arg("properties", () => GraphQLJSONObject, {
    nullable: true
  })),
  _ts_metadata17("design:type", Function),
  _ts_metadata17("design:paramtypes", [
    typeof GraphQLContext === "undefined" ? Object : GraphQLContext,
    typeof GenerateCopilotResponseInput === "undefined" ? Object : GenerateCopilotResponseInput,
    typeof CopilotRequestContextProperties === "undefined" ? Object : CopilotRequestContextProperties
  ]),
  _ts_metadata17("design:returntype", Promise)
], CopilotResolver.prototype, "generateCopilotResponse", null);
CopilotResolver = _ts_decorate17([
  Resolver(() => CopilotResponse)
], CopilotResolver);

// src/lib/integrations/shared.ts
import { useDeferStream } from "@graphql-yoga/plugin-defer-stream";

// src/lib/logger.ts
import createPinoLogger from "pino";
import pretty from "pino-pretty";
function createLogger(options) {
  const { level, component } = options || {};
  const stream = pretty({
    colorize: true
  });
  const logger2 = createPinoLogger({
    level: process.env.LOG_LEVEL || level || "error",
    redact: {
      paths: [
        "pid",
        "hostname"
      ],
      remove: true
    }
  }, stream);
  if (component) {
    return logger2.child({
      component
    });
  } else {
    return logger2;
  }
}
__name(createLogger, "createLogger");

// src/graphql/resolvers/state.resolver.ts
import { Arg as Arg2, Resolver as Resolver2 } from "type-graphql";
import { Ctx as Ctx2 } from "type-graphql";
import { Query as Query2 } from "type-graphql";

// src/graphql/types/load-agent-state-response.type.ts
import { Field as Field17, ObjectType as ObjectType6 } from "type-graphql";
function _ts_decorate18(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate18, "_ts_decorate");
function _ts_metadata18(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata18, "_ts_metadata");
var LoadAgentStateResponse = class {
  threadId;
  threadExists;
  state;
  messages;
};
__name(LoadAgentStateResponse, "LoadAgentStateResponse");
_ts_decorate18([
  Field17(() => String),
  _ts_metadata18("design:type", String)
], LoadAgentStateResponse.prototype, "threadId", void 0);
_ts_decorate18([
  Field17(() => Boolean),
  _ts_metadata18("design:type", Boolean)
], LoadAgentStateResponse.prototype, "threadExists", void 0);
_ts_decorate18([
  Field17(() => String),
  _ts_metadata18("design:type", String)
], LoadAgentStateResponse.prototype, "state", void 0);
_ts_decorate18([
  Field17(() => String),
  _ts_metadata18("design:type", String)
], LoadAgentStateResponse.prototype, "messages", void 0);
LoadAgentStateResponse = _ts_decorate18([
  ObjectType6()
], LoadAgentStateResponse);

// src/graphql/inputs/load-agent-state.input.ts
import { Field as Field18, InputType as InputType12 } from "type-graphql";
function _ts_decorate19(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate19, "_ts_decorate");
function _ts_metadata19(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata19, "_ts_metadata");
var LoadAgentStateInput = class {
  threadId;
  agentName;
};
__name(LoadAgentStateInput, "LoadAgentStateInput");
_ts_decorate19([
  Field18(() => String),
  _ts_metadata19("design:type", String)
], LoadAgentStateInput.prototype, "threadId", void 0);
_ts_decorate19([
  Field18(() => String),
  _ts_metadata19("design:type", String)
], LoadAgentStateInput.prototype, "agentName", void 0);
LoadAgentStateInput = _ts_decorate19([
  InputType12()
], LoadAgentStateInput);

// src/graphql/resolvers/state.resolver.ts
import { CopilotKitAgentDiscoveryError as CopilotKitAgentDiscoveryError2 } from "@copilotkit/shared";
function _ts_decorate20(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate20, "_ts_decorate");
function _ts_metadata20(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata20, "_ts_metadata");
function _ts_param2(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
__name(_ts_param2, "_ts_param");
var StateResolver = class {
  async loadAgentState(ctx, data) {
    const agents = await ctx._copilotkit.runtime.getAllAgents(ctx);
    const hasAgent = agents.some((agent) => agent.name === data.agentName);
    if (!hasAgent) {
      throw new CopilotKitAgentDiscoveryError2({
        agentName: data.agentName,
        availableAgents: agents.map((a) => ({
          name: a.name,
          id: a.name
        }))
      });
    }
    const state = await ctx._copilotkit.runtime.loadAgentState(ctx, data.threadId, data.agentName);
    return state;
  }
};
__name(StateResolver, "StateResolver");
_ts_decorate20([
  Query2(() => LoadAgentStateResponse),
  _ts_param2(0, Ctx2()),
  _ts_param2(1, Arg2("data")),
  _ts_metadata20("design:type", Function),
  _ts_metadata20("design:paramtypes", [
    typeof GraphQLContext === "undefined" ? Object : GraphQLContext,
    typeof LoadAgentStateInput === "undefined" ? Object : LoadAgentStateInput
  ]),
  _ts_metadata20("design:returntype", Promise)
], StateResolver.prototype, "loadAgentState", null);
StateResolver = _ts_decorate20([
  Resolver2(() => LoadAgentStateResponse)
], StateResolver);

// src/lib/integrations/shared.ts
var packageJson2 = __toESM(require_package());
import { CopilotKitError as CopilotKitError8, CopilotKitErrorCode as CopilotKitErrorCode5 } from "@copilotkit/shared";
var logger = createLogger();
var addCustomHeaderPlugin = {
  onResponse({ response }) {
    response.headers.set("X-CopilotKit-Runtime-Version", packageJson2.version);
  }
};
async function createContext(initialContext, copilotKitContext, contextLogger, properties = {}) {
  logger.debug({
    copilotKitContext
  }, "Creating GraphQL context");
  const ctx = {
    ...initialContext,
    _copilotkit: {
      ...copilotKitContext
    },
    properties: {
      ...properties
    },
    logger: contextLogger
  };
  return ctx;
}
__name(createContext, "createContext");
function buildSchema(options = {}) {
  logger.debug("Building GraphQL schema...");
  const schema = buildSchemaSync({
    resolvers: [
      CopilotResolver,
      StateResolver
    ],
    emitSchemaFile: options.emitSchemaFile
  });
  logger.debug("GraphQL schema built successfully");
  return schema;
}
__name(buildSchema, "buildSchema");
function getCommonConfig(options) {
  var _a;
  const logLevel = process.env.LOG_LEVEL || options.logLevel || "error";
  const logger2 = createLogger({
    level: logLevel,
    component: "getCommonConfig"
  });
  const contextLogger = createLogger({
    level: logLevel
  });
  if (options.cloud) {
    telemetry_client_default.setCloudConfiguration({
      publicApiKey: options.cloud.publicApiKey,
      baseUrl: options.cloud.baseUrl
    });
  }
  if ((_a = options.properties) == null ? void 0 : _a._copilotkit) {
    telemetry_client_default.setGlobalProperties({
      _copilotkit: {
        ...options.properties._copilotkit
      }
    });
  }
  telemetry_client_default.setGlobalProperties({
    runtime: {
      serviceAdapter: options.serviceAdapter.constructor.name
    }
  });
  const userErrorCodes = [
    CopilotKitErrorCode5.AGENT_NOT_FOUND,
    CopilotKitErrorCode5.API_NOT_FOUND,
    CopilotKitErrorCode5.REMOTE_ENDPOINT_NOT_FOUND,
    CopilotKitErrorCode5.CONFIGURATION_ERROR,
    CopilotKitErrorCode5.MISSING_PUBLIC_API_KEY_ERROR
  ];
  return {
    logging: createLogger({
      component: "Yoga GraphQL",
      level: logLevel
    }),
    schema: buildSchema(),
    plugins: [
      useDeferStream(),
      addCustomHeaderPlugin
    ],
    context: (ctx) => createContext(ctx, options, contextLogger, options.properties),
    // Suppress logging for user configuration errors
    maskedErrors: {
      maskError: (error, message, isDev) => {
        const originalError = error.originalError || error;
        const extensions = error.extensions;
        const errorCode = extensions == null ? void 0 : extensions.code;
        if (errorCode && userErrorCodes.includes(errorCode)) {
          console.debug("User configuration error:", error.message);
          return error;
        }
        if (originalError instanceof CopilotKitError8 && userErrorCodes.includes(originalError.code)) {
          console.debug("User configuration error:", error.message);
          return error;
        }
        console.error("Application error:", error);
        return error;
      }
    }
  };
}
__name(getCommonConfig, "getCommonConfig");

// src/lib/integrations/node-http/index.ts
function copilotRuntimeNodeHttpEndpoint(options) {
  var _a;
  const commonConfig = getCommonConfig(options);
  telemetry_client_default.setGlobalProperties({
    runtime: {
      framework: "node-http"
    }
  });
  if ((_a = options.properties) == null ? void 0 : _a._copilotkit) {
    telemetry_client_default.setGlobalProperties({
      _copilotkit: options.properties._copilotkit
    });
  }
  telemetry_client_default.capture("oss.runtime.instance_created", getRuntimeInstanceTelemetryInfo(options));
  const logger2 = commonConfig.logging;
  logger2.debug("Creating Node HTTP endpoint");
  const yoga = createYoga({
    ...commonConfig,
    graphqlEndpoint: options.endpoint
  });
  return yoga;
}
__name(copilotRuntimeNodeHttpEndpoint, "copilotRuntimeNodeHttpEndpoint");

export {
  LangGraphEventTypes,
  extractParametersFromSchema,
  convertMCPToolsToActions,
  generateMcpToolInstructions,
  CopilotRuntime,
  flattenToolCallsNoDuplicates,
  copilotKitEndpoint,
  langGraphPlatformEndpoint,
  resolveEndpointType,
  getRuntimeInstanceTelemetryInfo,
  telemetry_client_default,
  createLogger,
  addCustomHeaderPlugin,
  createContext,
  buildSchema,
  getCommonConfig,
  copilotRuntimeNodeHttpEndpoint
};
//# sourceMappingURL=chunk-IWD3ZNTV.mjs.map